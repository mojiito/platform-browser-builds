{"version":3,"file":"platform-browser.es5.js","sources":["../../../../packages/platform-browser/public_api.ts","../../../../packages/platform-browser/src/platform-browser.ts","../../../../packages/platform-browser/src/dom_renderer.ts","../../../../packages/platform-browser/src/dom_traverser.ts","../../../../packages/platform-browser/src/tokens.ts","../../../../packages/platform-browser/src/platform_ref.ts","../../../../packages/platform-browser/src/compiler/compiler.ts","../../../../packages/platform-browser/src/binding_parser.ts","../../../../packages/platform-browser/src/expression/expression.ts","../../../../packages/platform-browser/src/expression/expression_parser.ts","../../../../packages/platform-browser/src/chars.ts","../../../../packages/platform-browser/src/dom_visitor.ts","../../../../packages/platform-browser/src/facade/lang.ts","../../../../packages/platform-browser/src/facade/error.ts","../../../../packages/platform-browser/src/selector.ts","../../../../packages/platform-browser/src/facade/collection.ts"],"sourcesContent":["/**\n * @module\n * @description\n * Entry point for all public APIs of the core package.\n */\nexport {DOCUMENT,DomRendererFactory,BrowserPlatformRef,ExpressionParser,PLATFORM_PROVIDERS,platformBrowser} from './src/platform-browser';\n","import {\n  createPlatformFactory, PlatformRef, InjectionToken, RendererFactory, CORE_PROVIDERS, Provider\n} from 'mojiito-core';\nimport { unimplemented } from './facade/error';\nimport { ListWrapper } from './facade/collection';\nimport { BrowserPlatformRef } from './platform_ref';\nimport { DOCUMENT } from './tokens';\nimport { Compiler } from './compiler/compiler';\nimport { DomTraverser } from './dom_traverser';\nimport { DomRendererFactory } from './dom_renderer';\nimport { ExpressionParser } from './expression/expression';\nimport { BindingParser } from './binding_parser';\n\nexport { DOCUMENT, DomRendererFactory, BrowserPlatformRef, ExpressionParser };\n\nexport const /** @type {?} */ PLATFORM_PROVIDERS: Provider[] = [\n  { provide: PlatformRef, useClass: BrowserPlatformRef },\n  { provide: DOCUMENT, useValue: document },\n  { provide: RendererFactory, useClass: DomRendererFactory},\n  Compiler,\n  ExpressionParser,\n  BindingParser\n];\n\nexport const /** @type {?} */ platformBrowser = createPlatformFactory([PLATFORM_PROVIDERS, CORE_PROVIDERS]);\n","import { Renderer, RendererFactory, Injectable, RendererType, Visitor } from 'mojiito-core';\nimport { isPresent, stringify } from './facade/lang';\nimport { DOCUMENT } from './tokens';\nimport { DomTraverser } from './dom_traverser';\nimport { DomVisitor } from './dom_visitor';\n\nexport const /** @type {?} */ NAMESPACE_URIS: { [ns: string]: string } = {\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\n/**\n * @param {?} target\n * @return {?}\n */\nfunction getGlobalEventTarget(target: string): any {\n  if (target === 'window') {\n    return window;\n  }\n  if (target === 'document') {\n    return this.document;\n  }\n  if (target === 'body') {\n    return this.document.body;\n  }\n  return undefined;\n}\nexport class DomRendererFactory implements RendererFactory {\nprivate rendererByCompId = new Map<string, Renderer>();\nprivate defaultRenderer: Renderer;\nconstructor() {\n    this.defaultRenderer = new DefaultDomRenderer();\n  };\n/**\n * @param {?} element\n * @param {?} type\n * @return {?}\n */\ncreateRenderer(element: any, type: RendererType): Renderer {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n    return new ParseableDomRenderer(type.visitor, element);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction DomRendererFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nDomRendererFactory.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDomRendererFactory.ctorParameters;\n/** @type {?} */\nDomRendererFactory.prototype.rendererByCompId;\n/** @type {?} */\nDomRendererFactory.prototype.defaultRenderer;\n}\n\nexport class DefaultDomRenderer implements Renderer {\n/**\n * @param {?} context\n * @return {?}\n */\nparse(context: any) {\n    throw new Error(`Parse is not allowed on the DefaultDomRenderer!`);\n  }\n/**\n * @return {?}\n */\ndestroy(): void { }\n/**\n * @param {?} name\n * @param {?=} namespace\n * @return {?}\n */\ncreateElement(name: string, namespace?: string): any {\n    if (namespace) {\n      return document.createElementNS(NAMESPACE_URIS[namespace], name);\n    }\n    return document.createElement(name);\n  }\n/**\n * @param {?} value\n * @return {?}\n */\ncreateComment(value: string): any { return document.createComment(value); }\n/**\n * @param {?} value\n * @return {?}\n */\ncreateText(value: string): any { return document.createTextNode(value); }\n/**\n * @param {?} node\n * @return {?}\n */\ndestroyNode(node: any): void { }\n/**\n * @param {?} parent\n * @param {?} newChild\n * @return {?}\n */\nappendChild(parent: any, newChild: any): void { parent.appendChild(newChild); }\n/**\n * @param {?} parent\n * @param {?} newChild\n * @param {?} refChild\n * @return {?}\n */\ninsertBefore(parent: any, newChild: any, refChild: any): void {\n    if (parent) {\n      parent.insertBefore(newChild, refChild);\n    }\n  }\n/**\n * @param {?} parent\n * @param {?} oldChild\n * @return {?}\n */\nremoveChild(parent: any, oldChild: any): void {\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n  }\n/**\n * @param {?} selectorOrNode\n * @return {?}\n */\nselectRootElement(selectorOrNode: string | any): any {\n    let /** @type {?} */ el: any = selectorOrNode;\n    if (typeof selectorOrNode === 'string') {\n      el = document.querySelector(selectorOrNode);\n    }\n    if (!el) {\n      throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    return el;\n  }\n/**\n * @param {?} node\n * @return {?}\n */\nparentNode(node: any): any { return node.parentNode; }\n/**\n * @param {?} node\n * @return {?}\n */\nnextSibling(node: any): any { return node.nextSibling; }\n/**\n * @param {?} el\n * @param {?} name\n * @param {?} value\n * @param {?=} namespace\n * @return {?}\n */\nsetAttribute(el: any, name: string, value: string, namespace?: string): void {\n    if (namespace) {\n      el.setAttributeNS(NAMESPACE_URIS[namespace], namespace + ':' + name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n/**\n * @param {?} el\n * @param {?} name\n * @param {?=} namespace\n * @return {?}\n */\nremoveAttribute(el: any, name: string, namespace?: string): void {\n    if (namespace) {\n      el.removeAttributeNS(NAMESPACE_URIS[namespace], name);\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n/**\n * @param {?} el\n * @param {?} name\n * @return {?}\n */\naddClass(el: any, name: string): void { el.classList.add(name); }\n/**\n * @param {?} el\n * @param {?} name\n * @return {?}\n */\nremoveClass(el: any, name: string): void { el.classList.remove(name); }\n/**\n * @param {?} el\n * @param {?} style\n * @param {?} value\n * @param {?} hasVendorPrefix\n * @param {?} hasImportant\n * @return {?}\n */\nsetStyle(el: any, style: string, value: any, hasVendorPrefix: boolean, hasImportant: boolean):\n    void {\n    if (hasVendorPrefix || hasImportant) {\n      el.style.setProperty(style, value, hasImportant ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n/**\n * @param {?} el\n * @param {?} style\n * @param {?} hasVendorPrefix\n * @return {?}\n */\nremoveStyle(el: any, style: string, hasVendorPrefix: boolean): void {\n    if (hasVendorPrefix) {\n      el.style.removeProperty(style);\n    } else {\n      // IE requires '' instead of null\n      el.style[style] = '';\n    }\n  }\n/**\n * @param {?} el\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\nsetProperty(el: any, name: string, value: any): void { el[name] = value; }\n/**\n * @param {?} node\n * @param {?} value\n * @return {?}\n */\nsetValue(node: any, value: string): void { node.nodeValue = value; }\n/**\n * @param {?} target\n * @param {?} event\n * @param {?} callback\n * @return {?}\n */\nlisten(target: 'window' | 'document' | 'body' | any, event: string,\n    callback: (event: any) => boolean | void): () => void {\n    if (typeof target === 'string') {\n      target = getGlobalEventTarget(target);\n      if (!target) {\n        throw new Error(`Unsupported event target ${target} for event ${event}`);\n      }\n    }\n    target.addEventListener(event, /** @type {?} */(( callback as any)), false);\n    return () => target.removeEventListener(event, /** @type {?} */(( callback as any)), false);\n  }\n}\nexport class ParseableDomRenderer extends DefaultDomRenderer {\n/**\n * @param {?} _visitor\n * @param {?} hostElement\n */\nconstructor(private _visitor: Visitor,\npublic hostElement: Node) {\n    super();\n  }\n/**\n * @param {?} context\n * @return {?}\n */\nparse(context: any) {\n    const /** @type {?} */ traverser = new DomTraverser();\n    traverser.traverse(this.hostElement, this._visitor, context);\n  }\n/**\n * @param {?} node\n * @return {?}\n */\ndestroyNode(node: any) {\n    if (node instanceof Node) {\n      this.removeChild(node.parentNode, node);\n    }\n  }\n}\n\nfunction ParseableDomRenderer_tsickle_Closure_declarations() {\n/** @type {?} */\nParseableDomRenderer.prototype._visitor;\n/** @type {?} */\nParseableDomRenderer.prototype.hostElement;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Visitor, ViewData } from 'mojiito-core';\nimport { DomVisitor } from './dom_visitor';\n\nexport interface Traverser {\n  traverse(node: any, visitor: Visitor, context: ViewData): void;\n}\nexport class DomTraverser implements Traverser {\nprivate _nodeCount = 0;\nprivate _elementCount = 0;\nprivate _attributeCount = 0;\nprivate _textCount = 0;\nprivate _commentCount = 0;\nconstructor() { }\n/**\n * @param {?} node\n * @param {?} visitor\n * @param {?=} context\n * @return {?}\n */\ntraverse(node: Node, visitor: Visitor, context: ViewData = null) {\n    let /** @type {?} */ lclCntxt: ViewData = context;\n    this._nodeCount++;\n\n    if (node instanceof Element) {\n      lclCntxt = visitor.visitElement(node, lclCntxt) || lclCntxt;\n      this._elementCount++;\n    } else if (node instanceof Text) {\n      lclCntxt = visitor.visitText(node, lclCntxt) || lclCntxt;\n      this._textCount++;\n    } else if (node instanceof Comment) {\n      lclCntxt = visitor.visitComment(node, lclCntxt) || lclCntxt;\n      this._commentCount++;\n    }\n\n    // Check if context has changed and look up the corresponding\n    // NodeVisitor if available\n    if (!!lclCntxt && lclCntxt !== context) {\n      let /** @type {?} */ rendererType = lclCntxt.def.componentRendererType;\n      if (rendererType) {\n        visitor = rendererType.visitor;\n      }\n    } else {\n      // Traverse through all the attributes of the node\n      // if it is type of Element\n      if (node instanceof Element && node.attributes.length) {\n        for (let /** @type {?} */ i = 0, /** @type {?} */ max = node.attributes.length; i < max; i++) {\n          lclCntxt = visitor.visitAttribute(node, node.attributes[i], lclCntxt) || lclCntxt;\n          this._attributeCount++;\n        }\n      }\n    }\n\n    // Start traversing the child nodes\n    let /** @type {?} */ childNode = node.firstChild;\n    if (childNode) {\n      this.traverse(childNode, visitor, lclCntxt);\n      while (childNode = childNode.nextSibling) {\n        this.traverse(childNode, visitor, lclCntxt);\n      }\n    }\n  }\n}\n\nfunction DomTraverser_tsickle_Closure_declarations() {\n/** @type {?} */\nDomTraverser.prototype._nodeCount;\n/** @type {?} */\nDomTraverser.prototype._elementCount;\n/** @type {?} */\nDomTraverser.prototype._attributeCount;\n/** @type {?} */\nDomTraverser.prototype._textCount;\n/** @type {?} */\nDomTraverser.prototype._commentCount;\n}\n\n","import { InjectionToken } from 'mojiito-core';\n\nexport const /** @type {?} */ DOCUMENT = new InjectionToken<Document>('DocumentToken');\n","import {\n  PlatformRef, Injectable, Injector, ClassType, ApplicationRef,\n  ComponentResolver, ReflectiveInjector, ComponentFactoryResolver\n} from 'mojiito-core';\nimport { Compiler } from './compiler/compiler';\nexport class BrowserPlatformRef extends PlatformRef {\nprivate _destroyed = false;\nprivate _destroyListeners: Function[] = [];\n/**\n * @param {?} _injector\n * @param {?} _resolver\n * @param {?} _compiler\n */\nconstructor(private _injector: Injector,\nprivate _resolver: ComponentResolver,\nprivate _compiler: Compiler) {\n    super();\n  }\n/**\n * @return {?}\n */\nget injector(): Injector { return this._injector; }\n/**\n * @return {?}\n */\nget destroyed(): boolean { return this._destroyed; }\n/**\n * @template C\n * @param {?} component\n * @return {?}\n */\nbootstrapComponent<C>(component: ClassType<C>): void {\n    this._compiler.compileComponents([component]);\n    const /** @type {?} */ appInjector = ReflectiveInjector.resolveAndCreate([\n      {\n        provide: ComponentFactoryResolver,\n        useFactory: () => this._compiler.createComponentFactoryResolver()\n      },\n      ApplicationRef\n    ], this._injector);\n\n    const /** @type {?} */ app = /** @type {?} */(( appInjector.get(ApplicationRef) as ApplicationRef));\n    app.bootstrap(component);\n  }\n/**\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: () => void): void {\n    this._destroyListeners.push(callback);\n  }\n/**\n * @return {?}\n */\ndestroy(): void {\n    if (this._destroyed) {\n      throw new Error('The platform has already been destroyed!');\n    }\n    // TODO: destroy all se stuff\n    this._destroyListeners.forEach(listener => listener());\n    this._destroyed = true;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Injector, },\n{type: ComponentResolver, },\n{type: Compiler, },\n];\n}\n\nfunction BrowserPlatformRef_tsickle_Closure_declarations() {\n/** @type {?} */\nBrowserPlatformRef.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nBrowserPlatformRef.ctorParameters;\n/** @type {?} */\nBrowserPlatformRef.prototype._destroyed;\n/** @type {?} */\nBrowserPlatformRef.prototype._destroyListeners;\n/** @type {?} */\nBrowserPlatformRef.prototype._injector;\n/** @type {?} */\nBrowserPlatformRef.prototype._resolver;\n/** @type {?} */\nBrowserPlatformRef.prototype._compiler;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  ClassType, Component, ComponentResolver, Injectable, Renderer, RendererType, ComponentRef,\n  ComponentFactory, ComponentFactoryResolver, createComponentFactory, resolveReflectiveProviders,\n  ElementRef, Injector, ApplicationRef, Provider, ReflectiveInjector, ReflectorReader,\n  HostListener, ChildListener, createViewDefinitionFactory, SkipSelf, NodeFlags, NodeDef,\n  ViewDefinitionFactory, ViewDefinition, DepFlags, constructDependencies, ProviderDef, DepDef,\n  Visitor\n} from 'mojiito-core';\nimport { ListWrapper } from '../facade/collection';\nimport { stringify } from '../facade/lang';\nimport { DomVisitor } from '../dom_visitor';\nimport { DomTraverser } from '../dom_traverser';\nimport { BindingParser, EventBindingParseResult } from '../binding_parser';\nimport { CompileComponentSummary } from './compile_result';\nexport class Compiler {\nprivate _compileResults = new Map<ClassType<any>, CompileComponentSummary>();\n/**\n * @param {?} _resolver\n * @param {?} _bindParser\n */\nconstructor(private _resolver: ComponentResolver,\nprivate _bindParser: BindingParser) { }\n/**\n * @return {?}\n */\ncreateComponentFactoryResolver() {\n    const /** @type {?} */ factories: ComponentFactory<any>[] = [];\n    this._compileResults.forEach(summary => {\n      factories.push(summary.componentFactory);\n    });\n    return new ComponentFactoryResolver(factories);\n  }\n/**\n * @param {?} components\n * @return {?}\n */\ncompileComponents(components: ClassType<any>[]): CompileComponentSummary[] {\n    return components.map(c => this.compileComponent(c));\n  }\n/**\n * @template C\n * @param {?} component\n * @return {?}\n */\ncompileComponent<C>(component: ClassType<C>): CompileComponentSummary {\n    let /** @type {?} */ compileSummary = this._compileResults.get(component);\n    if (compileSummary) {\n      return compileSummary;\n    }\n\n    // grab component metadata\n    const /** @type {?} */ metadata = this._resolver.resolve(component);\n\n    // compile child components\n    let /** @type {?} */ childComponents: CompileComponentSummary[];\n    let /** @type {?} */ rendererType: RendererType;\n    if (metadata.components) {\n      childComponents = this.compileComponents(ListWrapper.flatten(metadata.components));\n\n      // create a renderer type with a visitor for this component with all\n      // sub components\n      rendererType = this._createComponentRendererType(new DomVisitor(childComponents));\n    }\n\n    // create a view definition factory for this component type\n    const /** @type {?} */ viewDefinitionFactory =\n      this._createComponentViewDef(component, metadata.providers, rendererType);\n\n    // create a component factory for this component type\n    const /** @type {?} */ componentFactory =\n      createComponentFactory(metadata.selector, component, viewDefinitionFactory);\n\n    compileSummary = {\n      type: component,\n      selector: metadata.selector,\n      hostListeners: metadata.host,\n      childListeners: metadata.childs,\n      componentFactory,\n      viewDefinitionFactory,\n      components: childComponents\n    };\n    this._compileResults.set(component, compileSummary);\n    return compileSummary;\n  }\n/**\n * @param {?} providers\n * @param {?} nodes\n * @param {?} nodeType\n * @return {?}\n */\nprivate _createProviderNodes(providers: Provider[], nodes: NodeDef[],\n    nodeType: NodeFlags): NodeDef[] {\n    const /** @type {?} */ nodeDefs = resolveReflectiveProviders(ListWrapper.flatten(providers))\n      .map((provider, index) => {\n        const /** @type {?} */ factory = provider.resolvedFactories[0];\n        const /** @type {?} */ node = /** @type {?} */(( <NodeDef>{\n          flags: nodeType,\n          index: nodes.length + index,\n          provider: /** @type {?} */(( <ProviderDef>{\n            token: provider.key.token,\n            tokenKey: provider.key.displayName,\n            factory: factory.factory,\n            deps: factory.dependencies.map(dep => {\n              let /** @type {?} */ flags = 0;\n              if (dep.optional) {\n                flags += DepFlags.Optional;\n              }\n              if (dep.visibility instanceof SkipSelf) {\n                flags += DepFlags.SkipSelf;\n              }\n              return /** @type {?} */(( <DepDef>{\n                flags,\n                token: dep.key.token,\n                tokenKey: dep.key.displayName\n              }));\n            })\n          }))\n        }));\n        return node;\n      });\n    nodes.push(...nodeDefs);\n    return nodeDefs;\n  }\n/**\n * @param {?} visitor\n * @return {?}\n */\nprivate _createComponentRendererType(visitor: Visitor): RendererType {\n    return {\n      visitor,\n      data: null\n    };\n  }\n/**\n * @param {?} component\n * @param {?} providers\n * @param {?} componentRendererType\n * @return {?}\n */\nprivate _createComponentViewDef(component: ClassType<any>, providers: Provider[],\n      componentRendererType: RendererType): ViewDefinitionFactory {\n    const /** @type {?} */ viewDefinitionFactory: ViewDefinitionFactory = () => {\n      const /** @type {?} */ nodes: NodeDef[] = [];\n      let /** @type {?} */ nodeFlags = NodeFlags.ComponentView;\n\n      // Create public provider instances and add to nodes\n      let /** @type {?} */ publicProviders: {[key: string]: NodeDef} = {};\n      if (providers) {\n        this._createProviderNodes(providers, nodes, NodeFlags.TypeProvider).forEach(node => {\n          publicProviders[node.provider.tokenKey] = node;\n        });\n        nodeFlags |= NodeFlags.TypeProvider;\n      }\n\n      // Create component instance and add to nodes\n      this._createProviderNodes([component], nodes, NodeFlags.TypeComponent);\n      const /** @type {?} */ componentProvider = nodes[nodes.length - 1];\n      nodeFlags |= NodeFlags.TypeComponent;\n\n      // Set allProviders to publicProviders plus private providers (componentProvider)\n      const /** @type {?} */ allProviders = publicProviders;\n      allProviders[componentProvider.provider.tokenKey] = componentProvider;\n\n      return /** @type {?} */(( <ViewDefinition>{\n        factory: viewDefinitionFactory,\n        nodeFlags,\n        nodes,\n        componentProvider,\n        publicProviders,\n        allProviders,\n        componentRendererType\n      }));\n    };\n    return viewDefinitionFactory;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ComponentResolver, },\n{type: BindingParser, },\n];\n}\n\nfunction Compiler_tsickle_Closure_declarations() {\n/** @type {?} */\nCompiler.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nCompiler.ctorParameters;\n/** @type {?} */\nCompiler.prototype._compileResults;\n/** @type {?} */\nCompiler.prototype._resolver;\n/** @type {?} */\nCompiler.prototype._bindParser;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Injectable } from 'mojiito-core';\nimport { Expression, ExpressionParser } from './expression/expression';\nimport { isPresent } from './facade/lang';\n\n// tslint:disable-next-line:max-line-length\nconst /** @type {?} */ BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n\n// Group 1 = \"bind-\"\nconst /** @type {?} */ KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst /** @type {?} */ KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst /** @type {?} */ KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst /** @type {?} */ KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst /** @type {?} */ KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst /** @type {?} */ KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst /** @type {?} */ IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nconst /** @type {?} */ IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nconst /** @type {?} */ IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nconst /** @type {?} */ IDENT_EVENT_IDX = 10;\n\nconst /** @type {?} */ CLASS_ATTR = 'class';\nexport class BindingParser {\n/**\n * @param {?} _exprParser\n */\nconstructor(private _exprParser: ExpressionParser) { }\n/**\n * @param {?} name\n * @param {?} expression\n * @return {?}\n */\nparse(name: string, expression: string) {\n    const /** @type {?} */ bindParts = name.match(BIND_NAME_REGEXP);\n    const /** @type {?} */ expr = this._exprParser.parse(expression);\n    let /** @type {?} */ key: string;\n\n    if (isPresent(bindParts[KW_BIND_IDX])) {\n      unsupported('Property binding', name, expression);\n    } else if (bindParts[KW_REF_IDX]) {\n      unsupported('Variable declaration', name, expression);\n    } else if (bindParts[KW_ON_IDX]) {\n      return new EventBindingParseResult(bindParts[IDENT_KW_IDX], expr);\n    } else if (bindParts[KW_BINDON_IDX]) {\n      unsupported('Two way binding', name, expression);\n    } else if (bindParts[KW_AT_IDX]) {\n      unsupported('Animations', name, expression);\n    } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n      unsupported('Two way binding', name, expression);\n    } else if (bindParts[IDENT_PROPERTY_IDX]) {\n      unsupported('Property binding', name, expression);\n    } else if (bindParts[IDENT_EVENT_IDX]) {\n      return new EventBindingParseResult(bindParts[IDENT_EVENT_IDX], expr);\n    } else {\n      throw new Error(`Unknown binding name: ${name}`);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ExpressionParser, },\n];\n}\n\nfunction BindingParser_tsickle_Closure_declarations() {\n/** @type {?} */\nBindingParser.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nBindingParser.ctorParameters;\n/** @type {?} */\nBindingParser.prototype._exprParser;\n}\n\nexport class BindingParseResult {\n/**\n * @param {?} expression\n */\nconstructor(public expression: Expression) { }\n}\n\nfunction BindingParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nBindingParseResult.prototype.expression;\n}\n\nexport class EventBindingParseResult extends BindingParseResult {\n/**\n * @param {?} eventName\n * @param {?} expression\n */\nconstructor(public eventName: string, expression: Expression) {\n    super(expression);\n  }\n}\n\nfunction EventBindingParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nEventBindingParseResult.prototype.eventName;\n}\n\n/**\n * @param {?} type\n * @param {?} name\n * @param {?} expression\n * @return {?}\n */\nfunction unsupported(type: string, name: string, expression: string) {\n  throw new Error(`${type} is not yet supported: ${name}=\"${expression}\"`);\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Token, ExpressionParser } from './expression_parser';\n\nexport { Token, ExpressionParser };\nexport class Expression {\n/**\n * @param {?} tokens\n */\nconstructor(public tokens: Token[]) { }\n}\n\nfunction Expression_tsickle_Closure_declarations() {\n/** @type {?} */\nExpression.prototype.tokens;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport { Injectable } from 'mojiito-core';\nimport * as chars from '../chars';\nimport { NumberWrapper } from '../facade/lang';\nimport { Expression } from './expression';\nexport type TokenType = number;\nexport let TokenType: any = {};\nTokenType.Character = 0;\nTokenType.Identifier = 1;\nTokenType.Keyword = 2;\nTokenType.String = 3;\nTokenType.Operator = 4;\nTokenType.Number = 5;\nTokenType.Error = 6;\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\n\n\nconst /** @type {?} */ KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nexport class ExpressionParser {\n/**\n * @param {?} text\n * @return {?}\n */\ntokenize(text: string): Token[] {\n    const /** @type {?} */ scanner = new Scanner(text);\n    const /** @type {?} */ tokens: Token[] = [];\n    let /** @type {?} */ token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n/**\n * @param {?} text\n * @return {?}\n */\nparse(text: string): Expression {\n    return new Expression(this.tokenize(text));\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ExpressionParser_tsickle_Closure_declarations() {\n/** @type {?} */\nExpressionParser.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nExpressionParser.ctorParameters;\n}\n\nexport class Token {\n/**\n * @param {?} index\n * @param {?} type\n * @param {?} numValue\n * @param {?} strValue\n */\nconstructor(\npublic index: number,\npublic type: TokenType,\npublic numValue: number,\npublic strValue: string) { }\n/**\n * @param {?} code\n * @return {?}\n */\nisCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n/**\n * @return {?}\n */\nisNumber(): boolean { return this.type == TokenType.Number; }\n/**\n * @return {?}\n */\nisString(): boolean { return this.type == TokenType.String; }\n/**\n * @param {?} operater\n * @return {?}\n */\nisOperator(operater: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operater;\n  }\n/**\n * @return {?}\n */\nisIdentifier(): boolean { return this.type == TokenType.Identifier; }\n/**\n * @return {?}\n */\nisKeyword(): boolean { return this.type == TokenType.Keyword; }\n/**\n * @return {?}\n */\nisKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n/**\n * @return {?}\n */\nisKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n/**\n * @return {?}\n */\nisKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n/**\n * @return {?}\n */\nisKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n/**\n * @return {?}\n */\nisKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n/**\n * @return {?}\n */\nisKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n/**\n * @return {?}\n */\nisError(): boolean { return this.type == TokenType.Error; }\n/**\n * @return {?}\n */\ntoNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n/**\n * @return {?}\n */\ntoString(): string {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction Token_tsickle_Closure_declarations() {\n/** @type {?} */\nToken.prototype.index;\n/** @type {?} */\nToken.prototype.type;\n/** @type {?} */\nToken.prototype.numValue;\n/** @type {?} */\nToken.prototype.strValue;\n}\n\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const /** @type {?} */ EOF: Token = new Token(-1, TokenType.Character, 0, '');\nclass Scanner {\n  length: number;\n  peek = 0;\n  index = -1;\n/**\n * @param {?} input\n */\nconstructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n/**\n * @return {?}\n */\nadvance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n/**\n * @return {?}\n */\nscanToken(): Token {\n    const /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n    let /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const /** @type {?} */ start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n          newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n          start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n/**\n * @param {?} start\n * @param {?} code\n * @return {?}\n */\nscanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n/**\n * @param {?} start\n * @param {?} str\n * @return {?}\n */\nscanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n/**\n * Tokenize a 2/3 char long operator\n * \n * @param {?} start start index in the expression\n * @param {?} one first symbol (always part of the operator)\n * @param {?} twoCode code point for the second symbol\n * @param {?} two second symbol (part of the operator when the second code point matches)\n * @param {?=} threeCode code point for the third symbol\n * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n * @return {?}\n */\nscanComplexOperator(\n    start: number, one: string, twoCode: number, two: string, threeCode?: number,\n    three?: string): Token {\n    this.advance();\n    let /** @type {?} */ str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n/**\n * @return {?}\n */\nscanIdentifier(): Token {\n    const /** @type {?} */ start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n      newIdentifierToken(start, str);\n  }\n/**\n * @param {?} start\n * @return {?}\n */\nscanNumber(start: number): Token {\n    let /** @type {?} */ simple: boolean = (this.index === start);\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek == chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    const /** @type {?} */ value: number = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n/**\n * @return {?}\n */\nscanString(): Token {\n    const /** @type {?} */ start = this.index;\n    const /** @type {?} */ quote = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let /** @type {?} */ buffer = '';\n    let /** @type {?} */ marker = this.index;\n    const /** @type {?} */ input = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let /** @type {?} */ unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const /** @type {?} */ hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let /** @type {?} */ i = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const /** @type {?} */ last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n/**\n * @param {?} message\n * @param {?} offset\n * @return {?}\n */\nerror(message: string, offset: number): Token {\n    const /** @type {?} */ position: number = this.index + offset;\n    return newErrorToken(\n      position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction Scanner_tsickle_Closure_declarations() {\n/** @type {?} */\nScanner.prototype.length;\n/** @type {?} */\nScanner.prototype.peek;\n/** @type {?} */\nScanner.prototype.index;\n/** @type {?} */\nScanner.prototype.input;\n}\n\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n    (code == chars.$_) || (code == chars.$$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const /** @type {?} */ scanner = new Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n    (code == chars.$$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport const $EOF = 0;\nexport const /** @type {?} */ $TAB = 9;\nexport const /** @type {?} */ $LF = 10;\nexport const /** @type {?} */ $VTAB = 11;\nexport const /** @type {?} */ $FF = 12;\nexport const /** @type {?} */ $CR = 13;\nexport const /** @type {?} */ $SPACE = 32;\nexport const /** @type {?} */ $BANG = 33;\nexport const /** @type {?} */ $DQ = 34;\nexport const /** @type {?} */ $HASH = 35;\nexport const /** @type {?} */ $$ = 36;\nexport const /** @type {?} */ $PERCENT = 37;\nexport const /** @type {?} */ $AMPERSAND = 38;\nexport const /** @type {?} */ $SQ = 39;\nexport const /** @type {?} */ $LPAREN = 40;\nexport const /** @type {?} */ $RPAREN = 41;\nexport const /** @type {?} */ $STAR = 42;\nexport const /** @type {?} */ $PLUS = 43;\nexport const /** @type {?} */ $COMMA = 44;\nexport const /** @type {?} */ $MINUS = 45;\nexport const /** @type {?} */ $PERIOD = 46;\nexport const /** @type {?} */ $SLASH = 47;\nexport const /** @type {?} */ $COLON = 58;\nexport const /** @type {?} */ $SEMICOLON = 59;\nexport const /** @type {?} */ $LT = 60;\nexport const /** @type {?} */ $EQ = 61;\nexport const /** @type {?} */ $GT = 62;\nexport const /** @type {?} */ $QUESTION = 63;\n\nexport const /** @type {?} */ $0 = 48;\nexport const /** @type {?} */ $9 = 57;\n\nexport const /** @type {?} */ $A = 65;\nexport const /** @type {?} */ $E = 69;\nexport const /** @type {?} */ $F = 70;\nexport const /** @type {?} */ $X = 88;\nexport const /** @type {?} */ $Z = 90;\n\nexport const /** @type {?} */ $LBRACKET = 91;\nexport const /** @type {?} */ $BACKSLASH = 92;\nexport const /** @type {?} */ $RBRACKET = 93;\nexport const /** @type {?} */ $CARET = 94;\nexport const /** @type {?} */ $_ = 95;\n\nexport const /** @type {?} */ $a = 97;\nexport const /** @type {?} */ $e = 101;\nexport const /** @type {?} */ $f = 102;\nexport const /** @type {?} */ $n = 110;\nexport const /** @type {?} */ $r = 114;\nexport const /** @type {?} */ $t = 116;\nexport const /** @type {?} */ $u = 117;\nexport const /** @type {?} */ $v = 118;\nexport const /** @type {?} */ $x = 120;\nexport const /** @type {?} */ $z = 122;\n\nexport const /** @type {?} */ $LBRACE = 123;\nexport const /** @type {?} */ $BAR = 124;\nexport const /** @type {?} */ $RBRACE = 125;\nexport const /** @type {?} */ $NBSP = 160;\n\nexport const /** @type {?} */ $PIPE = 124;\nexport const /** @type {?} */ $TILDA = 126;\nexport const /** @type {?} */ $AT = 64;\n\nexport const /** @type {?} */ $BT = 96;\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isAsciiLetter(code: number): boolean {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isAsciiHexDigit(code: number): boolean {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n","import { CssSelector, SelectorMatcher } from './selector';\nimport { ClassType, Visitor, createView, ViewData } from 'mojiito-core';\nimport { WrappedError } from './facade/error';\nimport { stringify } from './facade/lang';\nimport { ListWrapper } from './facade/collection';\nimport { CompileComponentSummary } from './compiler/compile_result';\nexport class DomVisitor implements Visitor {\nprivate _selectorMatcher = new SelectorMatcher();\nprivate _componentsIndex = new Map<CompileComponentSummary, number>();\n/**\n * @param {?} components\n */\nconstructor(components: CompileComponentSummary[]) {\n    components.forEach((component, index) => {\n      const selector = CssSelector.parse(component.selector);\n      this._selectorMatcher.addSelectables(selector, component);\n      this._componentsIndex.set(component, index);\n    });\n  }\n/**\n * @param {?} element\n * @param {?} context\n * @return {?}\n */\nvisitElement(element: Element, context: ViewData): any {\n    const /** @type {?} */ elementCssSelector = CssSelector.fromElement(element);\n    let /** @type {?} */ matchingComponent: CompileComponentSummary;\n    this._selectorMatcher.match(elementCssSelector, (selector, component) => {\n      if (matchingComponent) {\n        throw new MultipleComponentsOnElementError([matchingComponent.type, component.type]);\n      }\n      matchingComponent = component;\n    });\n\n    // if no matching component return current context\n    if (!matchingComponent) {\n      return context;\n    }\n\n    // console.log(`Found ${stringify(matchingComponent.type)} on element:`, element);\n\n    const /** @type {?} */ viewDef = matchingComponent.viewDefinitionFactory();\n    const /** @type {?} */ view = createView(context.root, context, element, viewDef);\n\n    // console.log(`Created ${stringify(matchingComponent.type)} ` +\n    //   `with parent ${stringify(context.component.constructor)}`);\n\n    ListWrapper.forEach(element.attributes, attr => {\n\n    });\n\n    return view;\n  }\n/**\n * @param {?} element\n * @param {?} attr\n * @param {?} context\n * @return {?}\n */\nvisitAttribute(element: Element, attr: Attr, context: any) { }\n/**\n * @param {?} text\n * @param {?} context\n * @return {?}\n */\nvisitText(text: Text, context: any) { }\n/**\n * @param {?} comment\n * @param {?} context\n * @return {?}\n */\nvisitComment(comment: Comment, context: any) { }\n\n}\n\nfunction DomVisitor_tsickle_Closure_declarations() {\n/** @type {?} */\nDomVisitor.prototype._selectorMatcher;\n/** @type {?} */\nDomVisitor.prototype._componentsIndex;\n}\n\nexport class ParseError extends WrappedError {\n/**\n * @param {?} error\n */\nconstructor(error: any) {\n    super(`Parse Error`, error);\n  }\n}\nexport class MultipleComponentsOnElementError extends ParseError {\n/**\n * @param {?} components\n */\nconstructor(components: ClassType<any>[]) {\n    const names = components.map(c => stringify(c)).join(', ');\n    super(`The selectors of the components ${names} are matching the same DOM Element. ` +\n      `Only one component per element is allowed.`);\n  }\n}\n","\n/**\n * Returns the class name of a type.\n * \n * @export\n * @template T\n * @param {?} klass\n * @return {?}\n */\nexport function getClassName<T>(klass: Function) {\n  return ( /** @type {?} */((klass as any))).name ? ( /** @type {?} */((klass as any))).name :\n    /^function\\s+([\\w\\$]+)\\s*\\(/.exec(this.toString())[1];\n}\n/**\n * Tries to stringify a token. A token can be any type.\n * \n * @export\n * @param {?} token\n * @return {?}\n */\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (token === undefined || token === null) {\n    return '' + token;\n  }\n  if (token.name) {\n    return token.name;\n  }\n  if (token.overriddenName) {\n    return token.overriddenName;\n  }\n  if (typeof token === 'function') {\n      return getClassName(token);\n  }\n  if (token instanceof HTMLElement) {\n    let /** @type {?} */ parts = token.toString().match(/\\w+/g);\n    if (parts && parts.length) {\n      return parts[parts.length - 1];\n    }\n  }\n\n  var /** @type {?} */ res = token.toString();\n  var /** @type {?} */ newLineIndex = res.indexOf('\\n');\n  return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);\n}\n\nexport interface BrowserNodeGlobal {\n  Object: typeof Object;\n  Array: typeof Array;\n  Map: typeof Map;\n  Set: typeof Set;\n  Date: DateConstructor;\n  RegExp: RegExpConstructor;\n  JSON: typeof JSON;\n  Math: any;  // typeof Math;\n  assert(condition: any): void;\n  Reflect: any;\n  setTimeout: Function;\n  clearTimeout: Function;\n  setInterval: Function;\n  clearInterval: Function;\n  encodeURI: Function;\n}\n\ndeclare var WorkerGlobalScope: any;\ndeclare var global: any;\nlet /** @type {?} */ globalScope: BrowserNodeGlobal;\nif (typeof window === 'undefined') {\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n    // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n    globalScope = /** @type {?} */(( <any>self));\n  } else {\n    globalScope = /** @type {?} */(( <any>global));\n  }\n} else {\n  globalScope = /** @type {?} */(( <any>window));\n}\nexport {globalScope as global};\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isPresent(obj: any): boolean {\n  return obj != null;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isBlank(obj: any): boolean {\n  return obj == null;\n}\nexport class NumberWrapper {\n/**\n * @param {?} text\n * @return {?}\n */\nstatic parseIntAutoRadix(text: string): number {\n    const /** @type {?} */ result: number = parseInt(text);\n    if (isNaN(result)) {\n      throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n  }\n/**\n * @param {?} value\n * @return {?}\n */\nstatic isNumeric(value: any): boolean { return !isNaN(value - parseFloat(value)); }\n}\n","\n/**\n * Convenience to throw an Error with 'unimplemented' as the message.\n * @return {?}\n */\nexport function unimplemented(): any {\n  throw new Error('unimplemented');\n}\nexport class BaseError extends Error {\n/**\n * \\@internal *\n */\n_nativeError: Error;\n/**\n * @param {?} message\n */\nconstructor(message: string) {\n    super(message);\n    // Errors don't use current this, instead they create a new instance.\n    // We have to do forward all of our api to the nativeInstance.\n    const nativeError = new Error(message) as any as Error;\n    this._nativeError = nativeError;\n  }\n/**\n * @return {?}\n */\nget message() { return this._nativeError.message; }\n/**\n * @param {?} message\n * @return {?}\n */\nset message(message) { this._nativeError.message = message; }\n/**\n * @return {?}\n */\nget name() { return this._nativeError.name; }\n/**\n * @return {?}\n */\nget stack() { return ( /** @type {?} */((this._nativeError as any))).stack; }\n/**\n * @param {?} value\n * @return {?}\n */\nset stack(value) { ( /** @type {?} */((this._nativeError as any))).stack = value; }\n/**\n * @return {?}\n */\ntoString() { return this._nativeError.toString(); }\n}\n\nfunction BaseError_tsickle_Closure_declarations() {\n/**\n * \\@internal *\n * @type {?}\n */\nBaseError.prototype._nativeError;\n}\n\nexport class WrappedError extends BaseError {\n  originalError: any;\n/**\n * @param {?} message\n * @param {?} error\n */\nconstructor(message: string, error: any) {\n    super(`${message} caused by: ${error instanceof Error ? error.message : error}`);\n    this.originalError = error;\n  }\n/**\n * @return {?}\n */\nget stack() {\n    return ( /** @type {?} */(((this.originalError instanceof Error ? this.originalError : this._nativeError) as any)))\n      .stack;\n  }\n}\n\nfunction WrappedError_tsickle_Closure_declarations() {\n/** @type {?} */\nWrappedError.prototype.originalError;\n}\n\n","import { ListWrapper } from './facade/collection';\n\nconst /** @type {?} */ _SELECTOR_REGEXP = new RegExp(\n  '(\\\\:not\\\\()|' +           // \":not(\"\n  '([-\\\\w]+)|' +         // \"tag\"\n  '(?:\\\\.([-\\\\w]+))|' +  // \".class\"\n  // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n  '(?:\\\\[([-.\\\\w*]+)(?:=([^\\\\]]*))?\\\\])|' +  // \"[name]\", \"[name=value]\"\n  '(\\\\))|' +                                 // \")\"\n  '(\\\\s*,\\\\s*)',                             // \",\"\n  'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string = null;\n  classNames: string[] = [];\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n/**\n * @param {?} element\n * @return {?}\n */\nstatic fromElement(element: Element): CssSelector {\n    const /** @type {?} */ selector = new CssSelector();\n    selector.setElement(element.tagName.toLocaleLowerCase());\n    ListWrapper.forEach(element.attributes, (attr: Attr) => {\n      if (attr.name.toLocaleLowerCase() !== 'class') {\n        selector.addAttribute(attr.name.trim(), attr.value.trim());\n      }\n    });\n    ListWrapper.forEach(element.classList, (c: string) => selector.addClassName(c));\n    return selector;\n  }\n/**\n * @param {?} selector\n * @return {?}\n */\nstatic parse(selector: string): CssSelector[] {\n    const /** @type {?} */ results: CssSelector[] = [];\n    const /** @type {?} */ _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n        cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let /** @type {?} */ cssSelector = new CssSelector();\n    let /** @type {?} */ match: string[];\n    let /** @type {?} */ current = cssSelector;\n    let /** @type {?} */ inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[1]) {\n        if (inNot) {\n          throw new Error('Nesting :not is not allowed in a selector');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      if (match[2]) {\n        current.setElement(match[2]);\n      }\n      if (match[3]) {\n        current.addClassName(match[3]);\n      }\n      if (match[4]) {\n        current.addAttribute(match[4], match[5]);\n      }\n      if (match[6]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[7]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n/**\n * @return {?}\n */\nisElementSelector(): boolean {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n      this.notSelectors.length === 0;\n  }\n/**\n * @return {?}\n */\nhasElementSelector(): boolean { return !!this.element; }\n/**\n * @param {?=} element\n * @return {?}\n */\nsetElement(element: string = null) { this.element = element; }\n/**\n * @param {?} name\n * @param {?=} value\n * @return {?}\n */\naddAttribute(name: string, value = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n/**\n * @param {?} name\n * @return {?}\n */\naddClassName(name: string) { this.classNames.push(name.toLowerCase()); }\n/**\n * @return {?}\n */\ntoString(): string {\n    let /** @type {?} */ res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n        const /** @type {?} */ name = this.attrs[i];\n        const /** @type {?} */ value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\n\nfunction CssSelector_tsickle_Closure_declarations() {\n/** @type {?} */\nCssSelector.prototype.element;\n/** @type {?} */\nCssSelector.prototype.classNames;\n/** @type {?} */\nCssSelector.prototype.attrs;\n/** @type {?} */\nCssSelector.prototype.notSelectors;\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher {\n/**\n * @param {?} notSelectors\n * @return {?}\n */\nstatic createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher {\n    const /** @type {?} */ notMatcher = new SelectorMatcher();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\nprivate _elementMap = new Map<string, SelectorContext[]>();\nprivate _elementPartialMap = new Map<string, SelectorMatcher>();\nprivate _classMap = new Map<string, SelectorContext[]>();\nprivate _classPartialMap = new Map<string, SelectorMatcher>();\nprivate _attrValueMap = new Map<string, Map<string, SelectorContext[]>>();\nprivate _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher>>();\nprivate _listContexts: SelectorListContext[] = [];\n/**\n * @param {?} cssSelectors\n * @param {?=} callbackCtxt\n * @return {?}\n */\naddSelectables(cssSelectors: CssSelector[], callbackCtxt?: any) {\n    let /** @type {?} */ listContext: SelectorListContext = null;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let /** @type {?} */ i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n    }\n  }\n/**\n * Add an object that can be found later on by calling `match`.\n * @param {?} cssSelector A css selector\n * @param {?} callbackCtxt An opaque object that will be given to the callback of the `match` function\n * @param {?} listContext\n * @return {?}\n */\nprivate _addSelectable(\n    cssSelector: CssSelector, callbackCtxt: any, listContext: SelectorListContext) {\n    let /** @type {?} */ matcher: SelectorMatcher = this;\n    const /** @type {?} */ element = cssSelector.element;\n    const /** @type {?} */ classNames = cssSelector.classNames;\n    const /** @type {?} */ attrs = cssSelector.attrs;\n    const /** @type {?} */ selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const /** @type {?} */ isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let /** @type {?} */ i = 0; i < classNames.length; i++) {\n        const /** @type {?} */ isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const /** @type {?} */ className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n        const /** @type {?} */ isTerminal = i === attrs.length - 2;\n        const /** @type {?} */ name = attrs[i];\n        const /** @type {?} */ value = attrs[i + 1];\n        if (isTerminal) {\n          const /** @type {?} */ terminalMap = matcher._attrValueMap;\n          let /** @type {?} */ terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const /** @type {?} */ partialMap = matcher._attrValuePartialMap;\n          let /** @type {?} */ partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n/**\n * @param {?} map\n * @param {?} name\n * @param {?} selectable\n * @return {?}\n */\nprivate _addTerminal(\n    map: Map<string, SelectorContext[]>, name: string, selectable: SelectorContext) {\n    let /** @type {?} */ terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n/**\n * @param {?} map\n * @param {?} name\n * @return {?}\n */\nprivate _addPartial(map: Map<string, SelectorMatcher>, name: string): SelectorMatcher {\n    let /** @type {?} */ matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n/**\n * Find the objects that have been added via `addSelectable`\n * whose css selector is contained in the given css selector.\n * @param {?} cssSelector A css selector\n * @param {?=} matchedCallback This callback will be called with the object handed into `addSelectable`\n * @return {?} boolean true if a match was found\n */\nmatch(cssSelector: CssSelector,\n    matchedCallback: (c: CssSelector, a: any) => void = function () { }): boolean {\n    let /** @type {?} */ result = false;\n    const /** @type {?} */ element = cssSelector.element;\n    const /** @type {?} */ classNames = cssSelector.classNames;\n    const /** @type {?} */ attrs = cssSelector.attrs;\n\n    for (let /** @type {?} */ i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n      result;\n\n    if (classNames) {\n      for (let /** @type {?} */ i = 0; i < classNames.length; i++) {\n        const /** @type {?} */ className = classNames[i];\n        result =\n          this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n          this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n          result;\n      }\n    }\n\n    if (attrs) {\n      for (let /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n        const /** @type {?} */ name = attrs[i];\n        const /** @type {?} */ value = attrs[i + 1];\n\n        const /** @type {?} */ terminalValuesMap = this._attrValueMap.get(name);\n        if (value) {\n          result =\n            this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const /** @type {?} */ partialValuesMap = this._attrValuePartialMap.get(name);\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n/**\n * \\@internal\n * @param {?} map\n * @param {?} name\n * @param {?} cssSelector\n * @param {?} matchedCallback\n * @return {?}\n */\n_matchTerminal(\n    map: Map<string, SelectorContext[]>, name: string, cssSelector: CssSelector,\n    matchedCallback: (c: CssSelector, a: any) => void): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let /** @type {?} */ selectables: SelectorContext[] = map.get(name) || [];\n    const /** @type {?} */ starSelectables: SelectorContext[] = map.get('*');\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let /** @type {?} */ selectable: SelectorContext;\n    let /** @type {?} */ result = false;\n    for (let /** @type {?} */ i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n/**\n * \\@internal\n * @param {?} map\n * @param {?} name\n * @param {?} cssSelector\n * @param {?} matchedCallback\n * @return {?}\n */\n_matchPartial(\n    map: Map<string, SelectorMatcher>, name: string, cssSelector: CssSelector,\n    matchedCallback: (c: CssSelector, a: any) => void): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const /** @type {?} */ nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\nfunction SelectorMatcher_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectorMatcher.prototype._elementMap;\n/** @type {?} */\nSelectorMatcher.prototype._elementPartialMap;\n/** @type {?} */\nSelectorMatcher.prototype._classMap;\n/** @type {?} */\nSelectorMatcher.prototype._classPartialMap;\n/** @type {?} */\nSelectorMatcher.prototype._attrValueMap;\n/** @type {?} */\nSelectorMatcher.prototype._attrValuePartialMap;\n/** @type {?} */\nSelectorMatcher.prototype._listContexts;\n}\n\nexport class SelectorListContext {\n  alreadyMatched = false;\n/**\n * @param {?} selectors\n */\nconstructor(public selectors: CssSelector[]) { }\n}\n\nfunction SelectorListContext_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectorListContext.prototype.alreadyMatched;\n/** @type {?} */\nSelectorListContext.prototype.selectors;\n}\n\nexport class SelectorContext {\n  notSelectors: CssSelector[];\n/**\n * @param {?} selector\n * @param {?} cbContext\n * @param {?} listContext\n */\nconstructor(\npublic selector: CssSelector,\npublic cbContext: any,\npublic listContext: SelectorListContext) {\n    this.notSelectors = selector.notSelectors;\n  }\n/**\n * @param {?} cssSelector\n * @param {?} callback\n * @return {?}\n */\nfinalize(cssSelector: CssSelector, callback: (c: CssSelector, a: any) => void): boolean {\n    let /** @type {?} */ result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const /** @type {?} */ notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n\nfunction SelectorContext_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectorContext.prototype.notSelectors;\n/** @type {?} */\nSelectorContext.prototype.selector;\n/** @type {?} */\nSelectorContext.prototype.cbContext;\n/** @type {?} */\nSelectorContext.prototype.listContext;\n}\n\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport class StringMapWrapper {\n/**\n * @template V\n * @param {?} m1\n * @param {?} m2\n * @return {?}\n */\nstatic merge<V>(m1: {[key: string]: V}, m2: {[key: string]: V}): {[key: string]: V} {\n    const /** @type {?} */ m: {[key: string]: V} = {};\n\n    for (const /** @type {?} */ k of Object.keys(m1)) {\n      m[k] = m1[k];\n    }\n\n    for (const /** @type {?} */ k of Object.keys(m2)) {\n      m[k] = m2[k];\n    }\n\n    return m;\n  }\n/**\n * @template V\n * @param {?} m1\n * @param {?} m2\n * @return {?}\n */\nstatic equals<V>(m1: {[key: string]: V}, m2: {[key: string]: V}): boolean {\n    const /** @type {?} */ k1 = Object.keys(m1);\n    const /** @type {?} */ k2 = Object.keys(m2);\n\n    if (k1.length != k2.length) {\n      return false;\n    }\n\n    for (let /** @type {?} */ i = 0; i < k1.length; i++) {\n      const /** @type {?} */ key = k1[i];\n      if (m1[key] !== m2[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\nexport class ListWrapper {\n/**\n * @template T\n * @param {?} arr\n * @param {?} condition\n * @return {?}\n */\nstatic findLast<T>(arr: T[], condition: (value: T) => boolean): T {\n    for (let /** @type {?} */ i = arr.length - 1; i >= 0; i--) {\n      if (condition(arr[i])) {\n        return arr[i];\n      }\n    }\n    return null;\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} items\n * @return {?}\n */\nstatic removeAll<T>(list: T[], items: T[]) {\n    for (let /** @type {?} */ i = 0; i < items.length; ++i) {\n      const /** @type {?} */ index = list.indexOf(items[i]);\n      if (index > -1) {\n        list.splice(index, 1);\n      }\n    }\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} el\n * @return {?}\n */\nstatic remove<T>(list: T[], el: T): boolean {\n    const /** @type {?} */ index = list.indexOf(el);\n    if (index > -1) {\n      list.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nstatic equals(a: any[], b: any[]): boolean {\n    if (a.length != b.length) return false;\n    for (let /** @type {?} */ i = 0; i < a.length; ++i) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n/**\n * @template T\n * @param {?} list\n * @return {?}\n */\nstatic flatten<T>(list: Array<T | T[]>): T[] {\n    return list.reduce((flat: any[], item: T | T[]): T[] => {\n      const /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;\n      return ( /** @type {?} */((<T[]>flat))).concat(flatItem);\n    }, []);\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} callback\n * @return {?}\n */\nstatic forEach<T>(list: ArrayLike<T>, callback: (item: T, index: number) => void): void {\n    for (let /** @type {?} */ i = 0, /** @type {?} */ max = list.length; i < max; i++) {\n      callback.call(callback, list[i], i);\n    }\n  }\n}\n"],"names":["ExpressionParser","chars.$EOF","chars.$BAR","chars.$AMPERSAND","chars.$BANG","chars.$GT","chars.$LT","chars.$QUESTION","chars.$CARET","chars.$PERCENT","chars.$STAR","chars.$MINUS","chars.$HASH","chars.$DQ","chars.$SQ","chars.$SEMICOLON","chars.$COLON","chars.$COMMA","chars.$RBRACKET","chars.$RPAREN","chars.$PERIOD","chars.isDigit"],"mappings":"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"}