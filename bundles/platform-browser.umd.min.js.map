{"version":3,"file":"platform-browser.umd.min.js","sources":["../../../../packages/platform-browser/src/dom_renderer.ts","../../../../packages/platform-browser/src/platform-browser.ts","../../../../packages/platform-browser/public_api.ts","../../../../packages/platform-browser/src/facade/lang.ts","../../../../packages/platform-browser/src/expression/expression_parser.ts","../../../../packages/platform-browser/src/expression/expression.ts","../../../../packages/platform-browser/src/selector.ts","../../../../packages/platform-browser/src/facade/error.ts","../../../../packages/platform-browser/src/dom_visitor.ts","../../../../packages/platform-browser/src/chars.ts","../../../../packages/platform-browser/src/binding_parser.ts","../../../../packages/platform-browser/src/compiler/compiler.ts","../../../../packages/platform-browser/src/platform_ref.ts","../../../../packages/platform-browser/src/dom_traverser.ts"],"sourcesContent":["import { Renderer, RendererFactory, Injectable, RendererType, Visitor } from 'mojiito-core';\nimport { isPresent, stringify } from './facade/lang';\nimport { DOCUMENT } from './tokens';\nimport { DomTraverser } from './dom_traverser';\nimport { DomVisitor } from './dom_visitor';\n\nexport const /** @type {?} */ NAMESPACE_URIS: { [ns: string]: string } = {\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\n/**\n * @param {?} target\n * @return {?}\n */\nfunction getGlobalEventTarget(target: string): any {\n  if (target === 'window') {\n    return window;\n  }\n  if (target === 'document') {\n    return this.document;\n  }\n  if (target === 'body') {\n    return this.document.body;\n  }\n  return undefined;\n}\nexport class DomRendererFactory implements RendererFactory {\nprivate rendererByCompId = new Map<string, Renderer>();\nprivate defaultRenderer: Renderer;\nconstructor() {\n    this.defaultRenderer = new DefaultDomRenderer();\n  };\n/**\n * @param {?} element\n * @param {?} type\n * @return {?}\n */\ncreateRenderer(element: any, type: RendererType): Renderer {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n    return new ParseableDomRenderer(type.visitor, element);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction DomRendererFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nDomRendererFactory.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDomRendererFactory.ctorParameters;\n/** @type {?} */\nDomRendererFactory.prototype.rendererByCompId;\n/** @type {?} */\nDomRendererFactory.prototype.defaultRenderer;\n}\n\nexport class DefaultDomRenderer implements Renderer {\n/**\n * @param {?} context\n * @return {?}\n */\nparse(context: any) {\n    throw new Error(`Parse is not allowed on the DefaultDomRenderer!`);\n  }\n/**\n * @return {?}\n */\ndestroy(): void { }\n/**\n * @param {?} name\n * @param {?=} namespace\n * @return {?}\n */\ncreateElement(name: string, namespace?: string): any {\n    if (namespace) {\n      return document.createElementNS(NAMESPACE_URIS[namespace], name);\n    }\n    return document.createElement(name);\n  }\n/**\n * @param {?} value\n * @return {?}\n */\ncreateComment(value: string): any { return document.createComment(value); }\n/**\n * @param {?} value\n * @return {?}\n */\ncreateText(value: string): any { return document.createTextNode(value); }\n/**\n * @param {?} node\n * @return {?}\n */\ndestroyNode(node: any): void { }\n/**\n * @param {?} parent\n * @param {?} newChild\n * @return {?}\n */\nappendChild(parent: any, newChild: any): void { parent.appendChild(newChild); }\n/**\n * @param {?} parent\n * @param {?} newChild\n * @param {?} refChild\n * @return {?}\n */\ninsertBefore(parent: any, newChild: any, refChild: any): void {\n    if (parent) {\n      parent.insertBefore(newChild, refChild);\n    }\n  }\n/**\n * @param {?} parent\n * @param {?} oldChild\n * @return {?}\n */\nremoveChild(parent: any, oldChild: any): void {\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n  }\n/**\n * @param {?} selectorOrNode\n * @return {?}\n */\nselectRootElement(selectorOrNode: string | any): any {\n    let /** @type {?} */ el: any = selectorOrNode;\n    if (typeof selectorOrNode === 'string') {\n      el = document.querySelector(selectorOrNode);\n    }\n    if (!el) {\n      throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    return el;\n  }\n/**\n * @param {?} node\n * @return {?}\n */\nparentNode(node: any): any { return node.parentNode; }\n/**\n * @param {?} node\n * @return {?}\n */\nnextSibling(node: any): any { return node.nextSibling; }\n/**\n * @param {?} el\n * @param {?} name\n * @param {?} value\n * @param {?=} namespace\n * @return {?}\n */\nsetAttribute(el: any, name: string, value: string, namespace?: string): void {\n    if (namespace) {\n      el.setAttributeNS(NAMESPACE_URIS[namespace], namespace + ':' + name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n/**\n * @param {?} el\n * @param {?} name\n * @param {?=} namespace\n * @return {?}\n */\nremoveAttribute(el: any, name: string, namespace?: string): void {\n    if (namespace) {\n      el.removeAttributeNS(NAMESPACE_URIS[namespace], name);\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n/**\n * @param {?} el\n * @param {?} name\n * @return {?}\n */\naddClass(el: any, name: string): void { el.classList.add(name); }\n/**\n * @param {?} el\n * @param {?} name\n * @return {?}\n */\nremoveClass(el: any, name: string): void { el.classList.remove(name); }\n/**\n * @param {?} el\n * @param {?} style\n * @param {?} value\n * @param {?} hasVendorPrefix\n * @param {?} hasImportant\n * @return {?}\n */\nsetStyle(el: any, style: string, value: any, hasVendorPrefix: boolean, hasImportant: boolean):\n    void {\n    if (hasVendorPrefix || hasImportant) {\n      el.style.setProperty(style, value, hasImportant ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n/**\n * @param {?} el\n * @param {?} style\n * @param {?} hasVendorPrefix\n * @return {?}\n */\nremoveStyle(el: any, style: string, hasVendorPrefix: boolean): void {\n    if (hasVendorPrefix) {\n      el.style.removeProperty(style);\n    } else {\n      // IE requires '' instead of null\n      el.style[style] = '';\n    }\n  }\n/**\n * @param {?} el\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\nsetProperty(el: any, name: string, value: any): void { el[name] = value; }\n/**\n * @param {?} node\n * @param {?} value\n * @return {?}\n */\nsetValue(node: any, value: string): void { node.nodeValue = value; }\n/**\n * @param {?} target\n * @param {?} event\n * @param {?} callback\n * @return {?}\n */\nlisten(target: 'window' | 'document' | 'body' | any, event: string,\n    callback: (event: any) => boolean | void): () => void {\n    if (typeof target === 'string') {\n      target = getGlobalEventTarget(target);\n      if (!target) {\n        throw new Error(`Unsupported event target ${target} for event ${event}`);\n      }\n    }\n    target.addEventListener(event, /** @type {?} */(( callback as any)), false);\n    return () => target.removeEventListener(event, /** @type {?} */(( callback as any)), false);\n  }\n}\nexport class ParseableDomRenderer extends DefaultDomRenderer {\n/**\n * @param {?} _visitor\n * @param {?} hostElement\n */\nconstructor(private _visitor: Visitor,\npublic hostElement: Node) {\n    super();\n  }\n/**\n * @param {?} context\n * @return {?}\n */\nparse(context: any) {\n    const /** @type {?} */ traverser = new DomTraverser();\n    traverser.traverse(this.hostElement, this._visitor, context);\n  }\n/**\n * @param {?} node\n * @return {?}\n */\ndestroyNode(node: any) {\n    if (node instanceof Node) {\n      this.removeChild(node.parentNode, node);\n    }\n  }\n}\n\nfunction ParseableDomRenderer_tsickle_Closure_declarations() {\n/** @type {?} */\nParseableDomRenderer.prototype._visitor;\n/** @type {?} */\nParseableDomRenderer.prototype.hostElement;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  createPlatformFactory, PlatformRef, InjectionToken, RendererFactory, CORE_PROVIDERS, Provider\n} from 'mojiito-core';\nimport { unimplemented } from './facade/error';\nimport { ListWrapper } from './facade/collection';\nimport { BrowserPlatformRef } from './platform_ref';\nimport { DOCUMENT } from './tokens';\nimport { Compiler } from './compiler/compiler';\nimport { DomTraverser } from './dom_traverser';\nimport { DomRendererFactory } from './dom_renderer';\nimport { ExpressionParser } from './expression/expression';\nimport { BindingParser } from './binding_parser';\n\nexport { DOCUMENT, DomRendererFactory, BrowserPlatformRef, ExpressionParser };\n\nexport const /** @type {?} */ PLATFORM_PROVIDERS: Provider[] = [\n  { provide: PlatformRef, useClass: BrowserPlatformRef },\n  { provide: DOCUMENT, useValue: document },\n  { provide: RendererFactory, useClass: DomRendererFactory},\n  Compiler,\n  ExpressionParser,\n  BindingParser\n];\n\nexport const /** @type {?} */ platformBrowser = createPlatformFactory([PLATFORM_PROVIDERS, CORE_PROVIDERS]);\n","/**\n * @module\n * @description\n * Entry point for all public APIs of the core package.\n */\nexport {DOCUMENT,DomRendererFactory,BrowserPlatformRef,ExpressionParser,PLATFORM_PROVIDERS,platformBrowser} from './src/platform-browser';\n","\n/**\n * Returns the class name of a type.\n * \n * @export\n * @template T\n * @param {?} klass\n * @return {?}\n */\nexport function getClassName<T>(klass: Function) {\n  return ( /** @type {?} */((klass as any))).name ? ( /** @type {?} */((klass as any))).name :\n    /^function\\s+([\\w\\$]+)\\s*\\(/.exec(this.toString())[1];\n}\n/**\n * Tries to stringify a token. A token can be any type.\n * \n * @export\n * @param {?} token\n * @return {?}\n */\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (token === undefined || token === null) {\n    return '' + token;\n  }\n  if (token.name) {\n    return token.name;\n  }\n  if (token.overriddenName) {\n    return token.overriddenName;\n  }\n  if (typeof token === 'function') {\n      return getClassName(token);\n  }\n  if (token instanceof HTMLElement) {\n    let /** @type {?} */ parts = token.toString().match(/\\w+/g);\n    if (parts && parts.length) {\n      return parts[parts.length - 1];\n    }\n  }\n\n  var /** @type {?} */ res = token.toString();\n  var /** @type {?} */ newLineIndex = res.indexOf('\\n');\n  return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);\n}\n\nexport interface BrowserNodeGlobal {\n  Object: typeof Object;\n  Array: typeof Array;\n  Map: typeof Map;\n  Set: typeof Set;\n  Date: DateConstructor;\n  RegExp: RegExpConstructor;\n  JSON: typeof JSON;\n  Math: any;  // typeof Math;\n  assert(condition: any): void;\n  Reflect: any;\n  setTimeout: Function;\n  clearTimeout: Function;\n  setInterval: Function;\n  clearInterval: Function;\n  encodeURI: Function;\n}\n\ndeclare var WorkerGlobalScope: any;\ndeclare var global: any;\nlet /** @type {?} */ globalScope: BrowserNodeGlobal;\nif (typeof window === 'undefined') {\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n    // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n    globalScope = /** @type {?} */(( <any>self));\n  } else {\n    globalScope = /** @type {?} */(( <any>global));\n  }\n} else {\n  globalScope = /** @type {?} */(( <any>window));\n}\nexport {globalScope as global};\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isPresent(obj: any): boolean {\n  return obj != null;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isBlank(obj: any): boolean {\n  return obj == null;\n}\nexport class NumberWrapper {\n/**\n * @param {?} text\n * @return {?}\n */\nstatic parseIntAutoRadix(text: string): number {\n    const /** @type {?} */ result: number = parseInt(text);\n    if (isNaN(result)) {\n      throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n  }\n/**\n * @param {?} value\n * @return {?}\n */\nstatic isNumeric(value: any): boolean { return !isNaN(value - parseFloat(value)); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport { Injectable } from 'mojiito-core';\nimport * as chars from '../chars';\nimport { NumberWrapper } from '../facade/lang';\nimport { Expression } from './expression';\nexport type TokenType = number;\nexport let TokenType: any = {};\nTokenType.Character = 0;\nTokenType.Identifier = 1;\nTokenType.Keyword = 2;\nTokenType.String = 3;\nTokenType.Operator = 4;\nTokenType.Number = 5;\nTokenType.Error = 6;\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\n\n\nconst /** @type {?} */ KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nexport class ExpressionParser {\n/**\n * @param {?} text\n * @return {?}\n */\ntokenize(text: string): Token[] {\n    const /** @type {?} */ scanner = new Scanner(text);\n    const /** @type {?} */ tokens: Token[] = [];\n    let /** @type {?} */ token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n/**\n * @param {?} text\n * @return {?}\n */\nparse(text: string): Expression {\n    return new Expression(this.tokenize(text));\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ExpressionParser_tsickle_Closure_declarations() {\n/** @type {?} */\nExpressionParser.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nExpressionParser.ctorParameters;\n}\n\nexport class Token {\n/**\n * @param {?} index\n * @param {?} type\n * @param {?} numValue\n * @param {?} strValue\n */\nconstructor(\npublic index: number,\npublic type: TokenType,\npublic numValue: number,\npublic strValue: string) { }\n/**\n * @param {?} code\n * @return {?}\n */\nisCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n/**\n * @return {?}\n */\nisNumber(): boolean { return this.type == TokenType.Number; }\n/**\n * @return {?}\n */\nisString(): boolean { return this.type == TokenType.String; }\n/**\n * @param {?} operater\n * @return {?}\n */\nisOperator(operater: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operater;\n  }\n/**\n * @return {?}\n */\nisIdentifier(): boolean { return this.type == TokenType.Identifier; }\n/**\n * @return {?}\n */\nisKeyword(): boolean { return this.type == TokenType.Keyword; }\n/**\n * @return {?}\n */\nisKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n/**\n * @return {?}\n */\nisKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n/**\n * @return {?}\n */\nisKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n/**\n * @return {?}\n */\nisKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n/**\n * @return {?}\n */\nisKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n/**\n * @return {?}\n */\nisKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n/**\n * @return {?}\n */\nisError(): boolean { return this.type == TokenType.Error; }\n/**\n * @return {?}\n */\ntoNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n/**\n * @return {?}\n */\ntoString(): string {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction Token_tsickle_Closure_declarations() {\n/** @type {?} */\nToken.prototype.index;\n/** @type {?} */\nToken.prototype.type;\n/** @type {?} */\nToken.prototype.numValue;\n/** @type {?} */\nToken.prototype.strValue;\n}\n\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const /** @type {?} */ EOF: Token = new Token(-1, TokenType.Character, 0, '');\nclass Scanner {\n  length: number;\n  peek = 0;\n  index = -1;\n/**\n * @param {?} input\n */\nconstructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n/**\n * @return {?}\n */\nadvance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n/**\n * @return {?}\n */\nscanToken(): Token {\n    const /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n    let /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const /** @type {?} */ start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n          newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n          start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n/**\n * @param {?} start\n * @param {?} code\n * @return {?}\n */\nscanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n/**\n * @param {?} start\n * @param {?} str\n * @return {?}\n */\nscanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n/**\n * Tokenize a 2/3 char long operator\n * \n * @param {?} start start index in the expression\n * @param {?} one first symbol (always part of the operator)\n * @param {?} twoCode code point for the second symbol\n * @param {?} two second symbol (part of the operator when the second code point matches)\n * @param {?=} threeCode code point for the third symbol\n * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n * @return {?}\n */\nscanComplexOperator(\n    start: number, one: string, twoCode: number, two: string, threeCode?: number,\n    three?: string): Token {\n    this.advance();\n    let /** @type {?} */ str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n/**\n * @return {?}\n */\nscanIdentifier(): Token {\n    const /** @type {?} */ start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n      newIdentifierToken(start, str);\n  }\n/**\n * @param {?} start\n * @return {?}\n */\nscanNumber(start: number): Token {\n    let /** @type {?} */ simple: boolean = (this.index === start);\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek == chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    const /** @type {?} */ value: number = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n/**\n * @return {?}\n */\nscanString(): Token {\n    const /** @type {?} */ start = this.index;\n    const /** @type {?} */ quote = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let /** @type {?} */ buffer = '';\n    let /** @type {?} */ marker = this.index;\n    const /** @type {?} */ input = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let /** @type {?} */ unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const /** @type {?} */ hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let /** @type {?} */ i = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const /** @type {?} */ last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n/**\n * @param {?} message\n * @param {?} offset\n * @return {?}\n */\nerror(message: string, offset: number): Token {\n    const /** @type {?} */ position: number = this.index + offset;\n    return newErrorToken(\n      position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction Scanner_tsickle_Closure_declarations() {\n/** @type {?} */\nScanner.prototype.length;\n/** @type {?} */\nScanner.prototype.peek;\n/** @type {?} */\nScanner.prototype.index;\n/** @type {?} */\nScanner.prototype.input;\n}\n\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n    (code == chars.$_) || (code == chars.$$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const /** @type {?} */ scanner = new Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n    (code == chars.$$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Token, ExpressionParser } from './expression_parser';\n\nexport { Token, ExpressionParser };\nexport class Expression {\n/**\n * @param {?} tokens\n */\nconstructor(public tokens: Token[]) { }\n}\n\nfunction Expression_tsickle_Closure_declarations() {\n/** @type {?} */\nExpression.prototype.tokens;\n}\n\n","import { ListWrapper } from './facade/collection';\n\nconst /** @type {?} */ _SELECTOR_REGEXP = new RegExp(\n  '(\\\\:not\\\\()|' +           // \":not(\"\n  '([-\\\\w]+)|' +         // \"tag\"\n  '(?:\\\\.([-\\\\w]+))|' +  // \".class\"\n  // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n  '(?:\\\\[([-.\\\\w*]+)(?:=([^\\\\]]*))?\\\\])|' +  // \"[name]\", \"[name=value]\"\n  '(\\\\))|' +                                 // \")\"\n  '(\\\\s*,\\\\s*)',                             // \",\"\n  'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string = null;\n  classNames: string[] = [];\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n/**\n * @param {?} element\n * @return {?}\n */\nstatic fromElement(element: Element): CssSelector {\n    const /** @type {?} */ selector = new CssSelector();\n    selector.setElement(element.tagName.toLocaleLowerCase());\n    ListWrapper.forEach(element.attributes, (attr: Attr) => {\n      if (attr.name.toLocaleLowerCase() !== 'class') {\n        selector.addAttribute(attr.name.trim(), attr.value.trim());\n      }\n    });\n    ListWrapper.forEach(element.classList, (c: string) => selector.addClassName(c));\n    return selector;\n  }\n/**\n * @param {?} selector\n * @return {?}\n */\nstatic parse(selector: string): CssSelector[] {\n    const /** @type {?} */ results: CssSelector[] = [];\n    const /** @type {?} */ _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n        cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let /** @type {?} */ cssSelector = new CssSelector();\n    let /** @type {?} */ match: string[];\n    let /** @type {?} */ current = cssSelector;\n    let /** @type {?} */ inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[1]) {\n        if (inNot) {\n          throw new Error('Nesting :not is not allowed in a selector');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      if (match[2]) {\n        current.setElement(match[2]);\n      }\n      if (match[3]) {\n        current.addClassName(match[3]);\n      }\n      if (match[4]) {\n        current.addAttribute(match[4], match[5]);\n      }\n      if (match[6]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[7]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n/**\n * @return {?}\n */\nisElementSelector(): boolean {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n      this.notSelectors.length === 0;\n  }\n/**\n * @return {?}\n */\nhasElementSelector(): boolean { return !!this.element; }\n/**\n * @param {?=} element\n * @return {?}\n */\nsetElement(element: string = null) { this.element = element; }\n/**\n * @param {?} name\n * @param {?=} value\n * @return {?}\n */\naddAttribute(name: string, value = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n/**\n * @param {?} name\n * @return {?}\n */\naddClassName(name: string) { this.classNames.push(name.toLowerCase()); }\n/**\n * @return {?}\n */\ntoString(): string {\n    let /** @type {?} */ res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n        const /** @type {?} */ name = this.attrs[i];\n        const /** @type {?} */ value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\n\nfunction CssSelector_tsickle_Closure_declarations() {\n/** @type {?} */\nCssSelector.prototype.element;\n/** @type {?} */\nCssSelector.prototype.classNames;\n/** @type {?} */\nCssSelector.prototype.attrs;\n/** @type {?} */\nCssSelector.prototype.notSelectors;\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher {\n/**\n * @param {?} notSelectors\n * @return {?}\n */\nstatic createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher {\n    const /** @type {?} */ notMatcher = new SelectorMatcher();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\nprivate _elementMap = new Map<string, SelectorContext[]>();\nprivate _elementPartialMap = new Map<string, SelectorMatcher>();\nprivate _classMap = new Map<string, SelectorContext[]>();\nprivate _classPartialMap = new Map<string, SelectorMatcher>();\nprivate _attrValueMap = new Map<string, Map<string, SelectorContext[]>>();\nprivate _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher>>();\nprivate _listContexts: SelectorListContext[] = [];\n/**\n * @param {?} cssSelectors\n * @param {?=} callbackCtxt\n * @return {?}\n */\naddSelectables(cssSelectors: CssSelector[], callbackCtxt?: any) {\n    let /** @type {?} */ listContext: SelectorListContext = null;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let /** @type {?} */ i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n    }\n  }\n/**\n * Add an object that can be found later on by calling `match`.\n * @param {?} cssSelector A css selector\n * @param {?} callbackCtxt An opaque object that will be given to the callback of the `match` function\n * @param {?} listContext\n * @return {?}\n */\nprivate _addSelectable(\n    cssSelector: CssSelector, callbackCtxt: any, listContext: SelectorListContext) {\n    let /** @type {?} */ matcher: SelectorMatcher = this;\n    const /** @type {?} */ element = cssSelector.element;\n    const /** @type {?} */ classNames = cssSelector.classNames;\n    const /** @type {?} */ attrs = cssSelector.attrs;\n    const /** @type {?} */ selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const /** @type {?} */ isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let /** @type {?} */ i = 0; i < classNames.length; i++) {\n        const /** @type {?} */ isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const /** @type {?} */ className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n        const /** @type {?} */ isTerminal = i === attrs.length - 2;\n        const /** @type {?} */ name = attrs[i];\n        const /** @type {?} */ value = attrs[i + 1];\n        if (isTerminal) {\n          const /** @type {?} */ terminalMap = matcher._attrValueMap;\n          let /** @type {?} */ terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const /** @type {?} */ partialMap = matcher._attrValuePartialMap;\n          let /** @type {?} */ partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n/**\n * @param {?} map\n * @param {?} name\n * @param {?} selectable\n * @return {?}\n */\nprivate _addTerminal(\n    map: Map<string, SelectorContext[]>, name: string, selectable: SelectorContext) {\n    let /** @type {?} */ terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n/**\n * @param {?} map\n * @param {?} name\n * @return {?}\n */\nprivate _addPartial(map: Map<string, SelectorMatcher>, name: string): SelectorMatcher {\n    let /** @type {?} */ matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n/**\n * Find the objects that have been added via `addSelectable`\n * whose css selector is contained in the given css selector.\n * @param {?} cssSelector A css selector\n * @param {?=} matchedCallback This callback will be called with the object handed into `addSelectable`\n * @return {?} boolean true if a match was found\n */\nmatch(cssSelector: CssSelector,\n    matchedCallback: (c: CssSelector, a: any) => void = function () { }): boolean {\n    let /** @type {?} */ result = false;\n    const /** @type {?} */ element = cssSelector.element;\n    const /** @type {?} */ classNames = cssSelector.classNames;\n    const /** @type {?} */ attrs = cssSelector.attrs;\n\n    for (let /** @type {?} */ i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n      result;\n\n    if (classNames) {\n      for (let /** @type {?} */ i = 0; i < classNames.length; i++) {\n        const /** @type {?} */ className = classNames[i];\n        result =\n          this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n          this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n          result;\n      }\n    }\n\n    if (attrs) {\n      for (let /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n        const /** @type {?} */ name = attrs[i];\n        const /** @type {?} */ value = attrs[i + 1];\n\n        const /** @type {?} */ terminalValuesMap = this._attrValueMap.get(name);\n        if (value) {\n          result =\n            this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const /** @type {?} */ partialValuesMap = this._attrValuePartialMap.get(name);\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n/**\n * \\@internal\n * @param {?} map\n * @param {?} name\n * @param {?} cssSelector\n * @param {?} matchedCallback\n * @return {?}\n */\n_matchTerminal(\n    map: Map<string, SelectorContext[]>, name: string, cssSelector: CssSelector,\n    matchedCallback: (c: CssSelector, a: any) => void): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let /** @type {?} */ selectables: SelectorContext[] = map.get(name) || [];\n    const /** @type {?} */ starSelectables: SelectorContext[] = map.get('*');\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let /** @type {?} */ selectable: SelectorContext;\n    let /** @type {?} */ result = false;\n    for (let /** @type {?} */ i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n/**\n * \\@internal\n * @param {?} map\n * @param {?} name\n * @param {?} cssSelector\n * @param {?} matchedCallback\n * @return {?}\n */\n_matchPartial(\n    map: Map<string, SelectorMatcher>, name: string, cssSelector: CssSelector,\n    matchedCallback: (c: CssSelector, a: any) => void): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const /** @type {?} */ nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\nfunction SelectorMatcher_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectorMatcher.prototype._elementMap;\n/** @type {?} */\nSelectorMatcher.prototype._elementPartialMap;\n/** @type {?} */\nSelectorMatcher.prototype._classMap;\n/** @type {?} */\nSelectorMatcher.prototype._classPartialMap;\n/** @type {?} */\nSelectorMatcher.prototype._attrValueMap;\n/** @type {?} */\nSelectorMatcher.prototype._attrValuePartialMap;\n/** @type {?} */\nSelectorMatcher.prototype._listContexts;\n}\n\nexport class SelectorListContext {\n  alreadyMatched = false;\n/**\n * @param {?} selectors\n */\nconstructor(public selectors: CssSelector[]) { }\n}\n\nfunction SelectorListContext_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectorListContext.prototype.alreadyMatched;\n/** @type {?} */\nSelectorListContext.prototype.selectors;\n}\n\nexport class SelectorContext {\n  notSelectors: CssSelector[];\n/**\n * @param {?} selector\n * @param {?} cbContext\n * @param {?} listContext\n */\nconstructor(\npublic selector: CssSelector,\npublic cbContext: any,\npublic listContext: SelectorListContext) {\n    this.notSelectors = selector.notSelectors;\n  }\n/**\n * @param {?} cssSelector\n * @param {?} callback\n * @return {?}\n */\nfinalize(cssSelector: CssSelector, callback: (c: CssSelector, a: any) => void): boolean {\n    let /** @type {?} */ result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const /** @type {?} */ notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n\nfunction SelectorContext_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectorContext.prototype.notSelectors;\n/** @type {?} */\nSelectorContext.prototype.selector;\n/** @type {?} */\nSelectorContext.prototype.cbContext;\n/** @type {?} */\nSelectorContext.prototype.listContext;\n}\n\n","\n/**\n * Convenience to throw an Error with 'unimplemented' as the message.\n * @return {?}\n */\nexport function unimplemented(): any {\n  throw new Error('unimplemented');\n}\nexport class BaseError extends Error {\n/**\n * \\@internal *\n */\n_nativeError: Error;\n/**\n * @param {?} message\n */\nconstructor(message: string) {\n    super(message);\n    // Errors don't use current this, instead they create a new instance.\n    // We have to do forward all of our api to the nativeInstance.\n    const nativeError = new Error(message) as any as Error;\n    this._nativeError = nativeError;\n  }\n/**\n * @return {?}\n */\nget message() { return this._nativeError.message; }\n/**\n * @param {?} message\n * @return {?}\n */\nset message(message) { this._nativeError.message = message; }\n/**\n * @return {?}\n */\nget name() { return this._nativeError.name; }\n/**\n * @return {?}\n */\nget stack() { return ( /** @type {?} */((this._nativeError as any))).stack; }\n/**\n * @param {?} value\n * @return {?}\n */\nset stack(value) { ( /** @type {?} */((this._nativeError as any))).stack = value; }\n/**\n * @return {?}\n */\ntoString() { return this._nativeError.toString(); }\n}\n\nfunction BaseError_tsickle_Closure_declarations() {\n/**\n * \\@internal *\n * @type {?}\n */\nBaseError.prototype._nativeError;\n}\n\nexport class WrappedError extends BaseError {\n  originalError: any;\n/**\n * @param {?} message\n * @param {?} error\n */\nconstructor(message: string, error: any) {\n    super(`${message} caused by: ${error instanceof Error ? error.message : error}`);\n    this.originalError = error;\n  }\n/**\n * @return {?}\n */\nget stack() {\n    return ( /** @type {?} */(((this.originalError instanceof Error ? this.originalError : this._nativeError) as any)))\n      .stack;\n  }\n}\n\nfunction WrappedError_tsickle_Closure_declarations() {\n/** @type {?} */\nWrappedError.prototype.originalError;\n}\n\n","import { CssSelector, SelectorMatcher } from './selector';\nimport { ClassType, Visitor, createView, ViewData } from 'mojiito-core';\nimport { WrappedError } from './facade/error';\nimport { stringify } from './facade/lang';\nimport { ListWrapper } from './facade/collection';\nimport { CompileComponentSummary } from './compiler/compile_result';\nexport class DomVisitor implements Visitor {\nprivate _selectorMatcher = new SelectorMatcher();\nprivate _componentsIndex = new Map<CompileComponentSummary, number>();\n/**\n * @param {?} components\n */\nconstructor(components: CompileComponentSummary[]) {\n    components.forEach((component, index) => {\n      const selector = CssSelector.parse(component.selector);\n      this._selectorMatcher.addSelectables(selector, component);\n      this._componentsIndex.set(component, index);\n    });\n  }\n/**\n * @param {?} element\n * @param {?} context\n * @return {?}\n */\nvisitElement(element: Element, context: ViewData): any {\n    const /** @type {?} */ elementCssSelector = CssSelector.fromElement(element);\n    let /** @type {?} */ matchingComponent: CompileComponentSummary;\n    this._selectorMatcher.match(elementCssSelector, (selector, component) => {\n      if (matchingComponent) {\n        throw new MultipleComponentsOnElementError([matchingComponent.type, component.type]);\n      }\n      matchingComponent = component;\n    });\n\n    // if no matching component return current context\n    if (!matchingComponent) {\n      return context;\n    }\n\n    // console.log(`Found ${stringify(matchingComponent.type)} on element:`, element);\n\n    const /** @type {?} */ viewDef = matchingComponent.viewDefinitionFactory();\n    const /** @type {?} */ view = createView(context.root, context, element, viewDef);\n\n    // console.log(`Created ${stringify(matchingComponent.type)} ` +\n    //   `with parent ${stringify(context.component.constructor)}`);\n\n    ListWrapper.forEach(element.attributes, attr => {\n\n    });\n\n    return view;\n  }\n/**\n * @param {?} element\n * @param {?} attr\n * @param {?} context\n * @return {?}\n */\nvisitAttribute(element: Element, attr: Attr, context: any) { }\n/**\n * @param {?} text\n * @param {?} context\n * @return {?}\n */\nvisitText(text: Text, context: any) { }\n/**\n * @param {?} comment\n * @param {?} context\n * @return {?}\n */\nvisitComment(comment: Comment, context: any) { }\n\n}\n\nfunction DomVisitor_tsickle_Closure_declarations() {\n/** @type {?} */\nDomVisitor.prototype._selectorMatcher;\n/** @type {?} */\nDomVisitor.prototype._componentsIndex;\n}\n\nexport class ParseError extends WrappedError {\n/**\n * @param {?} error\n */\nconstructor(error: any) {\n    super(`Parse Error`, error);\n  }\n}\nexport class MultipleComponentsOnElementError extends ParseError {\n/**\n * @param {?} components\n */\nconstructor(components: ClassType<any>[]) {\n    const names = components.map(c => stringify(c)).join(', ');\n    super(`The selectors of the components ${names} are matching the same DOM Element. ` +\n      `Only one component per element is allowed.`);\n  }\n}\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport const $EOF = 0;\nexport const /** @type {?} */ $TAB = 9;\nexport const /** @type {?} */ $LF = 10;\nexport const /** @type {?} */ $VTAB = 11;\nexport const /** @type {?} */ $FF = 12;\nexport const /** @type {?} */ $CR = 13;\nexport const /** @type {?} */ $SPACE = 32;\nexport const /** @type {?} */ $BANG = 33;\nexport const /** @type {?} */ $DQ = 34;\nexport const /** @type {?} */ $HASH = 35;\nexport const /** @type {?} */ $$ = 36;\nexport const /** @type {?} */ $PERCENT = 37;\nexport const /** @type {?} */ $AMPERSAND = 38;\nexport const /** @type {?} */ $SQ = 39;\nexport const /** @type {?} */ $LPAREN = 40;\nexport const /** @type {?} */ $RPAREN = 41;\nexport const /** @type {?} */ $STAR = 42;\nexport const /** @type {?} */ $PLUS = 43;\nexport const /** @type {?} */ $COMMA = 44;\nexport const /** @type {?} */ $MINUS = 45;\nexport const /** @type {?} */ $PERIOD = 46;\nexport const /** @type {?} */ $SLASH = 47;\nexport const /** @type {?} */ $COLON = 58;\nexport const /** @type {?} */ $SEMICOLON = 59;\nexport const /** @type {?} */ $LT = 60;\nexport const /** @type {?} */ $EQ = 61;\nexport const /** @type {?} */ $GT = 62;\nexport const /** @type {?} */ $QUESTION = 63;\n\nexport const /** @type {?} */ $0 = 48;\nexport const /** @type {?} */ $9 = 57;\n\nexport const /** @type {?} */ $A = 65;\nexport const /** @type {?} */ $E = 69;\nexport const /** @type {?} */ $F = 70;\nexport const /** @type {?} */ $X = 88;\nexport const /** @type {?} */ $Z = 90;\n\nexport const /** @type {?} */ $LBRACKET = 91;\nexport const /** @type {?} */ $BACKSLASH = 92;\nexport const /** @type {?} */ $RBRACKET = 93;\nexport const /** @type {?} */ $CARET = 94;\nexport const /** @type {?} */ $_ = 95;\n\nexport const /** @type {?} */ $a = 97;\nexport const /** @type {?} */ $e = 101;\nexport const /** @type {?} */ $f = 102;\nexport const /** @type {?} */ $n = 110;\nexport const /** @type {?} */ $r = 114;\nexport const /** @type {?} */ $t = 116;\nexport const /** @type {?} */ $u = 117;\nexport const /** @type {?} */ $v = 118;\nexport const /** @type {?} */ $x = 120;\nexport const /** @type {?} */ $z = 122;\n\nexport const /** @type {?} */ $LBRACE = 123;\nexport const /** @type {?} */ $BAR = 124;\nexport const /** @type {?} */ $RBRACE = 125;\nexport const /** @type {?} */ $NBSP = 160;\n\nexport const /** @type {?} */ $PIPE = 124;\nexport const /** @type {?} */ $TILDA = 126;\nexport const /** @type {?} */ $AT = 64;\n\nexport const /** @type {?} */ $BT = 96;\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isAsciiLetter(code: number): boolean {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isAsciiHexDigit(code: number): boolean {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n","import { Injectable } from 'mojiito-core';\nimport { Expression, ExpressionParser } from './expression/expression';\nimport { isPresent } from './facade/lang';\n\n// tslint:disable-next-line:max-line-length\nconst /** @type {?} */ BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n\n// Group 1 = \"bind-\"\nconst /** @type {?} */ KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst /** @type {?} */ KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst /** @type {?} */ KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst /** @type {?} */ KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst /** @type {?} */ KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst /** @type {?} */ KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst /** @type {?} */ IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nconst /** @type {?} */ IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nconst /** @type {?} */ IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nconst /** @type {?} */ IDENT_EVENT_IDX = 10;\n\nconst /** @type {?} */ CLASS_ATTR = 'class';\nexport class BindingParser {\n/**\n * @param {?} _exprParser\n */\nconstructor(private _exprParser: ExpressionParser) { }\n/**\n * @param {?} name\n * @param {?} expression\n * @return {?}\n */\nparse(name: string, expression: string) {\n    const /** @type {?} */ bindParts = name.match(BIND_NAME_REGEXP);\n    const /** @type {?} */ expr = this._exprParser.parse(expression);\n    let /** @type {?} */ key: string;\n\n    if (isPresent(bindParts[KW_BIND_IDX])) {\n      unsupported('Property binding', name, expression);\n    } else if (bindParts[KW_REF_IDX]) {\n      unsupported('Variable declaration', name, expression);\n    } else if (bindParts[KW_ON_IDX]) {\n      return new EventBindingParseResult(bindParts[IDENT_KW_IDX], expr);\n    } else if (bindParts[KW_BINDON_IDX]) {\n      unsupported('Two way binding', name, expression);\n    } else if (bindParts[KW_AT_IDX]) {\n      unsupported('Animations', name, expression);\n    } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n      unsupported('Two way binding', name, expression);\n    } else if (bindParts[IDENT_PROPERTY_IDX]) {\n      unsupported('Property binding', name, expression);\n    } else if (bindParts[IDENT_EVENT_IDX]) {\n      return new EventBindingParseResult(bindParts[IDENT_EVENT_IDX], expr);\n    } else {\n      throw new Error(`Unknown binding name: ${name}`);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ExpressionParser, },\n];\n}\n\nfunction BindingParser_tsickle_Closure_declarations() {\n/** @type {?} */\nBindingParser.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nBindingParser.ctorParameters;\n/** @type {?} */\nBindingParser.prototype._exprParser;\n}\n\nexport class BindingParseResult {\n/**\n * @param {?} expression\n */\nconstructor(public expression: Expression) { }\n}\n\nfunction BindingParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nBindingParseResult.prototype.expression;\n}\n\nexport class EventBindingParseResult extends BindingParseResult {\n/**\n * @param {?} eventName\n * @param {?} expression\n */\nconstructor(public eventName: string, expression: Expression) {\n    super(expression);\n  }\n}\n\nfunction EventBindingParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nEventBindingParseResult.prototype.eventName;\n}\n\n/**\n * @param {?} type\n * @param {?} name\n * @param {?} expression\n * @return {?}\n */\nfunction unsupported(type: string, name: string, expression: string) {\n  throw new Error(`${type} is not yet supported: ${name}=\"${expression}\"`);\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  ClassType, Component, ComponentResolver, Injectable, Renderer, RendererType, ComponentRef,\n  ComponentFactory, ComponentFactoryResolver, createComponentFactory, resolveReflectiveProviders,\n  ElementRef, Injector, ApplicationRef, Provider, ReflectiveInjector, ReflectorReader,\n  HostListener, ChildListener, createViewDefinitionFactory, SkipSelf, NodeFlags, NodeDef,\n  ViewDefinitionFactory, ViewDefinition, DepFlags, constructDependencies, ProviderDef, DepDef,\n  Visitor\n} from 'mojiito-core';\nimport { ListWrapper } from '../facade/collection';\nimport { stringify } from '../facade/lang';\nimport { DomVisitor } from '../dom_visitor';\nimport { DomTraverser } from '../dom_traverser';\nimport { BindingParser, EventBindingParseResult } from '../binding_parser';\nimport { CompileComponentSummary } from './compile_result';\nexport class Compiler {\nprivate _compileResults = new Map<ClassType<any>, CompileComponentSummary>();\n/**\n * @param {?} _resolver\n * @param {?} _bindParser\n */\nconstructor(private _resolver: ComponentResolver,\nprivate _bindParser: BindingParser) { }\n/**\n * @return {?}\n */\ncreateComponentFactoryResolver() {\n    const /** @type {?} */ factories: ComponentFactory<any>[] = [];\n    this._compileResults.forEach(summary => {\n      factories.push(summary.componentFactory);\n    });\n    return new ComponentFactoryResolver(factories);\n  }\n/**\n * @param {?} components\n * @return {?}\n */\ncompileComponents(components: ClassType<any>[]): CompileComponentSummary[] {\n    return components.map(c => this.compileComponent(c));\n  }\n/**\n * @template C\n * @param {?} component\n * @return {?}\n */\ncompileComponent<C>(component: ClassType<C>): CompileComponentSummary {\n    let /** @type {?} */ compileSummary = this._compileResults.get(component);\n    if (compileSummary) {\n      return compileSummary;\n    }\n\n    // grab component metadata\n    const /** @type {?} */ metadata = this._resolver.resolve(component);\n\n    // compile child components\n    let /** @type {?} */ childComponents: CompileComponentSummary[];\n    let /** @type {?} */ rendererType: RendererType;\n    if (metadata.components) {\n      childComponents = this.compileComponents(ListWrapper.flatten(metadata.components));\n\n      // create a renderer type with a visitor for this component with all\n      // sub components\n      rendererType = this._createComponentRendererType(new DomVisitor(childComponents));\n    }\n\n    // create a view definition factory for this component type\n    const /** @type {?} */ viewDefinitionFactory =\n      this._createComponentViewDef(component, metadata.providers, rendererType);\n\n    // create a component factory for this component type\n    const /** @type {?} */ componentFactory =\n      createComponentFactory(metadata.selector, component, viewDefinitionFactory);\n\n    compileSummary = {\n      type: component,\n      selector: metadata.selector,\n      hostListeners: metadata.host,\n      childListeners: metadata.childs,\n      componentFactory,\n      viewDefinitionFactory,\n      components: childComponents\n    };\n    this._compileResults.set(component, compileSummary);\n    return compileSummary;\n  }\n/**\n * @param {?} providers\n * @param {?} nodes\n * @param {?} nodeType\n * @return {?}\n */\nprivate _createProviderNodes(providers: Provider[], nodes: NodeDef[],\n    nodeType: NodeFlags): NodeDef[] {\n    const /** @type {?} */ nodeDefs = resolveReflectiveProviders(ListWrapper.flatten(providers))\n      .map((provider, index) => {\n        const /** @type {?} */ factory = provider.resolvedFactories[0];\n        const /** @type {?} */ node = /** @type {?} */(( <NodeDef>{\n          flags: nodeType,\n          index: nodes.length + index,\n          provider: /** @type {?} */(( <ProviderDef>{\n            token: provider.key.token,\n            tokenKey: provider.key.displayName,\n            factory: factory.factory,\n            deps: factory.dependencies.map(dep => {\n              let /** @type {?} */ flags = 0;\n              if (dep.optional) {\n                flags += DepFlags.Optional;\n              }\n              if (dep.visibility instanceof SkipSelf) {\n                flags += DepFlags.SkipSelf;\n              }\n              return /** @type {?} */(( <DepDef>{\n                flags,\n                token: dep.key.token,\n                tokenKey: dep.key.displayName\n              }));\n            })\n          }))\n        }));\n        return node;\n      });\n    nodes.push(...nodeDefs);\n    return nodeDefs;\n  }\n/**\n * @param {?} visitor\n * @return {?}\n */\nprivate _createComponentRendererType(visitor: Visitor): RendererType {\n    return {\n      visitor,\n      data: null\n    };\n  }\n/**\n * @param {?} component\n * @param {?} providers\n * @param {?} componentRendererType\n * @return {?}\n */\nprivate _createComponentViewDef(component: ClassType<any>, providers: Provider[],\n      componentRendererType: RendererType): ViewDefinitionFactory {\n    const /** @type {?} */ viewDefinitionFactory: ViewDefinitionFactory = () => {\n      const /** @type {?} */ nodes: NodeDef[] = [];\n      let /** @type {?} */ nodeFlags = NodeFlags.ComponentView;\n\n      // Create public provider instances and add to nodes\n      let /** @type {?} */ publicProviders: {[key: string]: NodeDef} = {};\n      if (providers) {\n        this._createProviderNodes(providers, nodes, NodeFlags.TypeProvider).forEach(node => {\n          publicProviders[node.provider.tokenKey] = node;\n        });\n        nodeFlags |= NodeFlags.TypeProvider;\n      }\n\n      // Create component instance and add to nodes\n      this._createProviderNodes([component], nodes, NodeFlags.TypeComponent);\n      const /** @type {?} */ componentProvider = nodes[nodes.length - 1];\n      nodeFlags |= NodeFlags.TypeComponent;\n\n      // Set allProviders to publicProviders plus private providers (componentProvider)\n      const /** @type {?} */ allProviders = publicProviders;\n      allProviders[componentProvider.provider.tokenKey] = componentProvider;\n\n      return /** @type {?} */(( <ViewDefinition>{\n        factory: viewDefinitionFactory,\n        nodeFlags,\n        nodes,\n        componentProvider,\n        publicProviders,\n        allProviders,\n        componentRendererType\n      }));\n    };\n    return viewDefinitionFactory;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ComponentResolver, },\n{type: BindingParser, },\n];\n}\n\nfunction Compiler_tsickle_Closure_declarations() {\n/** @type {?} */\nCompiler.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nCompiler.ctorParameters;\n/** @type {?} */\nCompiler.prototype._compileResults;\n/** @type {?} */\nCompiler.prototype._resolver;\n/** @type {?} */\nCompiler.prototype._bindParser;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  PlatformRef, Injectable, Injector, ClassType, ApplicationRef,\n  ComponentResolver, ReflectiveInjector, ComponentFactoryResolver\n} from 'mojiito-core';\nimport { Compiler } from './compiler/compiler';\nexport class BrowserPlatformRef extends PlatformRef {\nprivate _destroyed = false;\nprivate _destroyListeners: Function[] = [];\n/**\n * @param {?} _injector\n * @param {?} _resolver\n * @param {?} _compiler\n */\nconstructor(private _injector: Injector,\nprivate _resolver: ComponentResolver,\nprivate _compiler: Compiler) {\n    super();\n  }\n/**\n * @return {?}\n */\nget injector(): Injector { return this._injector; }\n/**\n * @return {?}\n */\nget destroyed(): boolean { return this._destroyed; }\n/**\n * @template C\n * @param {?} component\n * @return {?}\n */\nbootstrapComponent<C>(component: ClassType<C>): void {\n    this._compiler.compileComponents([component]);\n    const /** @type {?} */ appInjector = ReflectiveInjector.resolveAndCreate([\n      {\n        provide: ComponentFactoryResolver,\n        useFactory: () => this._compiler.createComponentFactoryResolver()\n      },\n      ApplicationRef\n    ], this._injector);\n\n    const /** @type {?} */ app = /** @type {?} */(( appInjector.get(ApplicationRef) as ApplicationRef));\n    app.bootstrap(component);\n  }\n/**\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: () => void): void {\n    this._destroyListeners.push(callback);\n  }\n/**\n * @return {?}\n */\ndestroy(): void {\n    if (this._destroyed) {\n      throw new Error('The platform has already been destroyed!');\n    }\n    // TODO: destroy all se stuff\n    this._destroyListeners.forEach(listener => listener());\n    this._destroyed = true;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Injector, },\n{type: ComponentResolver, },\n{type: Compiler, },\n];\n}\n\nfunction BrowserPlatformRef_tsickle_Closure_declarations() {\n/** @type {?} */\nBrowserPlatformRef.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nBrowserPlatformRef.ctorParameters;\n/** @type {?} */\nBrowserPlatformRef.prototype._destroyed;\n/** @type {?} */\nBrowserPlatformRef.prototype._destroyListeners;\n/** @type {?} */\nBrowserPlatformRef.prototype._injector;\n/** @type {?} */\nBrowserPlatformRef.prototype._resolver;\n/** @type {?} */\nBrowserPlatformRef.prototype._compiler;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Visitor, ViewData } from 'mojiito-core';\nimport { DomVisitor } from './dom_visitor';\n\nexport interface Traverser {\n  traverse(node: any, visitor: Visitor, context: ViewData): void;\n}\nexport class DomTraverser implements Traverser {\nprivate _nodeCount = 0;\nprivate _elementCount = 0;\nprivate _attributeCount = 0;\nprivate _textCount = 0;\nprivate _commentCount = 0;\nconstructor() { }\n/**\n * @param {?} node\n * @param {?} visitor\n * @param {?=} context\n * @return {?}\n */\ntraverse(node: Node, visitor: Visitor, context: ViewData = null) {\n    let /** @type {?} */ lclCntxt: ViewData = context;\n    this._nodeCount++;\n\n    if (node instanceof Element) {\n      lclCntxt = visitor.visitElement(node, lclCntxt) || lclCntxt;\n      this._elementCount++;\n    } else if (node instanceof Text) {\n      lclCntxt = visitor.visitText(node, lclCntxt) || lclCntxt;\n      this._textCount++;\n    } else if (node instanceof Comment) {\n      lclCntxt = visitor.visitComment(node, lclCntxt) || lclCntxt;\n      this._commentCount++;\n    }\n\n    // Check if context has changed and look up the corresponding\n    // NodeVisitor if available\n    if (!!lclCntxt && lclCntxt !== context) {\n      let /** @type {?} */ rendererType = lclCntxt.def.componentRendererType;\n      if (rendererType) {\n        visitor = rendererType.visitor;\n      }\n    } else {\n      // Traverse through all the attributes of the node\n      // if it is type of Element\n      if (node instanceof Element && node.attributes.length) {\n        for (let /** @type {?} */ i = 0, /** @type {?} */ max = node.attributes.length; i < max; i++) {\n          lclCntxt = visitor.visitAttribute(node, node.attributes[i], lclCntxt) || lclCntxt;\n          this._attributeCount++;\n        }\n      }\n    }\n\n    // Start traversing the child nodes\n    let /** @type {?} */ childNode = node.firstChild;\n    if (childNode) {\n      this.traverse(childNode, visitor, lclCntxt);\n      while (childNode = childNode.nextSibling) {\n        this.traverse(childNode, visitor, lclCntxt);\n      }\n    }\n  }\n}\n\nfunction DomTraverser_tsickle_Closure_declarations() {\n/** @type {?} */\nDomTraverser.prototype._nodeCount;\n/** @type {?} */\nDomTraverser.prototype._elementCount;\n/** @type {?} */\nDomTraverser.prototype._attributeCount;\n/** @type {?} */\nDomTraverser.prototype._textCount;\n/** @type {?} */\nDomTraverser.prototype._commentCount;\n}\n\n"],"names":["DefaultDomRenderer","prototype","listen","target","event","callback","addEventListener","removeEventListener","ParseableDomRenderer","_visitor","hostElement","destroyNode","node","Node","ExpressionParser","PLATFORM_PROVIDERS","stringify","token","undefined","name","overriddenName","getClassName","HTMLElement","parts","toString","match","length","res","newLineIndex","indexOf","unescape","code","$n","$LF","$f","$FF","$CR","$VTAB","getGlobalEventTarget","window","this","document","globalScope","call","list","i","CssSelector","fromElement","element","selector","addAttribute","attr","trim","value","parse","results","_addResult","cssSel","notSelectors","classNames","attrs","push","cssSelector","current","inNot","_SELECTOR_REGEXP","lastIndex","exec","Error","setElement","addClassName","toLowerCase","forEach","klass","_classMap","Map","SelectorMatcher","_addSelectable","callbackCtxt","listContext","matcher","selectable","SelectorContext","isTerminal","_addTerminal","_elementMap","_addPartial","_elementPartialMap","className","_classPartialMap","terminalMap","_attrValueMap","terminalValuesMap","get","set","partialMap","_attrValuePartialMap","matchedCallback","result","_listContexts","alreadyMatched","_matchTerminal","_matchPartial","map","selectables","starSelectables","concat","SelectorListContext","selectors","finalize","notMatcher","createNotMatcher","BaseError","_super","message","__extends","stack","Object","defineProperty","WrappedError","WorkerGlobalScope","self","parseInt","text","DomVisitor","visitElement","context","matchingComponent","elementCssSelector","MultipleComponentsOnElementError","type","component","ParseError","error","_this","names","$EOF","$TAB","$SPACE","$BANG","$DQ","$HASH","$$","$PERCENT","$AMPERSAND","$SQ","$LPAREN","$RPAREN","$STAR","$PLUS","$COMMA","$MINUS","$PERIOD","$SLASH","$COLON","$SEMICOLON","$LT","$EQ","$GT","$QUESTION","$0","$9","$A","$E","$Z","$LBRACKET","$BACKSLASH","$RBRACKET","$CARET","$_","$a","$e","$r","$t","$u","TokenType","Character","Identifier","Keyword","String","Operator","Number","Token$$1","index","numValue","strValue","isKeywordNull","toNumber","Scanner","input","peek","charCodeAt","scanToken","isIdentifierStart","scanIdentifier","isDigit","scanNumber","start","chars.$COMMA","advance","newCharacterToken","chars.$SQ","chars.$DQ","$LBRACE","chars.$HASH","chars.$MINUS","chars.$STAR","chars.$PERCENT","scanCharacter","chars.$QUESTION","scanString","chars.$LT","chars.$GT","chars.$BANG","chars.$AMPERSAND","scanOperator","fromCharCode","chars.$BAR","scanComplexOperator","one","twoCode","two","threeCode","three","str","newOperatorToken","isIdentifierPart","simple","isExponentStart","isExponentSign","newNumberToken","buffer","substring","marker","unescapedCode","hex","test","offset","Expression","IDENT_BANANA_BOX_IDX","BindingParser","expression","bindParts","BIND_NAME_REGEXP","expr","_exprParser","isPresent","KW_BIND_IDX","unsupported","KW_REF_IDX","KW_ON_IDX","EventBindingParseResult","IDENT_KW_IDX","KW_BINDON_IDX","KW_AT_IDX","IDENT_EVENT_IDX","BindingParseResult","_compileResults","factories","compileSummary","rendererType","metadata","components","_createComponentRendererType","childComponents","viewDefinitionFactory","_createComponentViewDef","providers","componentFactory","mojiitoCore","createComponentFactory","Compiler","_createProviderNodes","nodes","nodeType","nodeDefs","resolveReflectiveProviders","ListWrapper","flatten","provider","factory","resolvedFactories","flags","key","tokenKey","displayName","deps","dependencies","dep","optional","visibility","SkipSelf","nodeFlags","publicProviders","componentProvider","allProviders","Injectable","BrowserPlatformRef","bootstrapComponent","_compiler","compileComponents","_destroyListeners","destroy","_destroyed","InjectionToken","Injector","ComponentResolver","DomTraverser","traverse","visitor","lclCntxt","_nodeCount","Element","Text","visitText","_textCount","visitComment","_commentCount","def","componentRendererType","attributes","max","_attributeCount","childNode","firstChild","nextSibling","NAMESPACE_URIS","createElement","namespace","createComment"],"mappings":"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"}