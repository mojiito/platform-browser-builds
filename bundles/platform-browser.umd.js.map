{"version":3,"file":"platform-browser.umd.js","sources":["../../../../packages/platform-browser/public_api.ts","../../../../packages/platform-browser/src/platform-browser.ts","../../../../packages/platform-browser/src/dom_renderer.ts","../../../../packages/platform-browser/src/dom_traverser.ts","../../../../packages/platform-browser/src/tokens.ts","../../../../packages/platform-browser/src/platform_ref.ts","../../../../packages/platform-browser/src/compiler/compiler.ts","../../../../packages/platform-browser/src/binding_parser.ts","../../../../packages/platform-browser/src/expression/expression.ts","../../../../packages/platform-browser/src/expression/expression_parser.ts","../../../../packages/platform-browser/src/chars.ts","../../../../packages/platform-browser/src/dom_visitor.ts","../../../../packages/platform-browser/src/facade/lang.ts","../../../../packages/platform-browser/src/facade/error.ts","../../../../packages/platform-browser/src/selector.ts","../../../../packages/platform-browser/src/facade/collection.ts"],"sourcesContent":["/**\n * @module\n * @description\n * Entry point for all public APIs of the core package.\n */\nexport {DOCUMENT,DomRendererFactory,BrowserPlatformRef,ExpressionParser,PLATFORM_PROVIDERS,platformBrowser} from './src/platform-browser';\n","import {\n  createPlatformFactory, PlatformRef, InjectionToken, RendererFactory, CORE_PROVIDERS, Provider\n} from 'mojiito-core';\nimport { unimplemented } from './facade/error';\nimport { ListWrapper } from './facade/collection';\nimport { BrowserPlatformRef } from './platform_ref';\nimport { DOCUMENT } from './tokens';\nimport { Compiler } from './compiler/compiler';\nimport { DomTraverser } from './dom_traverser';\nimport { DomRendererFactory } from './dom_renderer';\nimport { ExpressionParser } from './expression/expression';\nimport { BindingParser } from './binding_parser';\n\nexport { DOCUMENT, DomRendererFactory, BrowserPlatformRef, ExpressionParser };\n\nexport const /** @type {?} */ PLATFORM_PROVIDERS: Provider[] = [\n  { provide: PlatformRef, useClass: BrowserPlatformRef },\n  { provide: DOCUMENT, useValue: document },\n  { provide: RendererFactory, useClass: DomRendererFactory},\n  Compiler,\n  ExpressionParser,\n  BindingParser\n];\n\nexport const /** @type {?} */ platformBrowser = createPlatformFactory([PLATFORM_PROVIDERS, CORE_PROVIDERS]);\n","import { Renderer, RendererFactory, Injectable, RendererType, Visitor } from 'mojiito-core';\nimport { isPresent, stringify } from './facade/lang';\nimport { DOCUMENT } from './tokens';\nimport { DomTraverser } from './dom_traverser';\nimport { DomVisitor } from './dom_visitor';\n\nexport const /** @type {?} */ NAMESPACE_URIS: { [ns: string]: string } = {\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\n/**\n * @param {?} target\n * @return {?}\n */\nfunction getGlobalEventTarget(target: string): any {\n  if (target === 'window') {\n    return window;\n  }\n  if (target === 'document') {\n    return this.document;\n  }\n  if (target === 'body') {\n    return this.document.body;\n  }\n  return undefined;\n}\nexport class DomRendererFactory implements RendererFactory {\nprivate rendererByCompId = new Map<string, Renderer>();\nprivate defaultRenderer: Renderer;\nconstructor() {\n    this.defaultRenderer = new DefaultDomRenderer();\n  };\n/**\n * @param {?} element\n * @param {?} type\n * @return {?}\n */\ncreateRenderer(element: any, type: RendererType): Renderer {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n    return new ParseableDomRenderer(type.visitor, element);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction DomRendererFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nDomRendererFactory.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDomRendererFactory.ctorParameters;\n/** @type {?} */\nDomRendererFactory.prototype.rendererByCompId;\n/** @type {?} */\nDomRendererFactory.prototype.defaultRenderer;\n}\n\nexport class DefaultDomRenderer implements Renderer {\n/**\n * @param {?} context\n * @return {?}\n */\nparse(context: any) {\n    throw new Error(`Parse is not allowed on the DefaultDomRenderer!`);\n  }\n/**\n * @return {?}\n */\ndestroy(): void { }\n/**\n * @param {?} name\n * @param {?=} namespace\n * @return {?}\n */\ncreateElement(name: string, namespace?: string): any {\n    if (namespace) {\n      return document.createElementNS(NAMESPACE_URIS[namespace], name);\n    }\n    return document.createElement(name);\n  }\n/**\n * @param {?} value\n * @return {?}\n */\ncreateComment(value: string): any { return document.createComment(value); }\n/**\n * @param {?} value\n * @return {?}\n */\ncreateText(value: string): any { return document.createTextNode(value); }\n/**\n * @param {?} node\n * @return {?}\n */\ndestroyNode(node: any): void { }\n/**\n * @param {?} parent\n * @param {?} newChild\n * @return {?}\n */\nappendChild(parent: any, newChild: any): void { parent.appendChild(newChild); }\n/**\n * @param {?} parent\n * @param {?} newChild\n * @param {?} refChild\n * @return {?}\n */\ninsertBefore(parent: any, newChild: any, refChild: any): void {\n    if (parent) {\n      parent.insertBefore(newChild, refChild);\n    }\n  }\n/**\n * @param {?} parent\n * @param {?} oldChild\n * @return {?}\n */\nremoveChild(parent: any, oldChild: any): void {\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n  }\n/**\n * @param {?} selectorOrNode\n * @return {?}\n */\nselectRootElement(selectorOrNode: string | any): any {\n    let /** @type {?} */ el: any = selectorOrNode;\n    if (typeof selectorOrNode === 'string') {\n      el = document.querySelector(selectorOrNode);\n    }\n    if (!el) {\n      throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    return el;\n  }\n/**\n * @param {?} node\n * @return {?}\n */\nparentNode(node: any): any { return node.parentNode; }\n/**\n * @param {?} node\n * @return {?}\n */\nnextSibling(node: any): any { return node.nextSibling; }\n/**\n * @param {?} el\n * @param {?} name\n * @param {?} value\n * @param {?=} namespace\n * @return {?}\n */\nsetAttribute(el: any, name: string, value: string, namespace?: string): void {\n    if (namespace) {\n      el.setAttributeNS(NAMESPACE_URIS[namespace], namespace + ':' + name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n/**\n * @param {?} el\n * @param {?} name\n * @param {?=} namespace\n * @return {?}\n */\nremoveAttribute(el: any, name: string, namespace?: string): void {\n    if (namespace) {\n      el.removeAttributeNS(NAMESPACE_URIS[namespace], name);\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n/**\n * @param {?} el\n * @param {?} name\n * @return {?}\n */\naddClass(el: any, name: string): void { el.classList.add(name); }\n/**\n * @param {?} el\n * @param {?} name\n * @return {?}\n */\nremoveClass(el: any, name: string): void { el.classList.remove(name); }\n/**\n * @param {?} el\n * @param {?} style\n * @param {?} value\n * @param {?} hasVendorPrefix\n * @param {?} hasImportant\n * @return {?}\n */\nsetStyle(el: any, style: string, value: any, hasVendorPrefix: boolean, hasImportant: boolean):\n    void {\n    if (hasVendorPrefix || hasImportant) {\n      el.style.setProperty(style, value, hasImportant ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n/**\n * @param {?} el\n * @param {?} style\n * @param {?} hasVendorPrefix\n * @return {?}\n */\nremoveStyle(el: any, style: string, hasVendorPrefix: boolean): void {\n    if (hasVendorPrefix) {\n      el.style.removeProperty(style);\n    } else {\n      // IE requires '' instead of null\n      el.style[style] = '';\n    }\n  }\n/**\n * @param {?} el\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\nsetProperty(el: any, name: string, value: any): void { el[name] = value; }\n/**\n * @param {?} node\n * @param {?} value\n * @return {?}\n */\nsetValue(node: any, value: string): void { node.nodeValue = value; }\n/**\n * @param {?} target\n * @param {?} event\n * @param {?} callback\n * @return {?}\n */\nlisten(target: 'window' | 'document' | 'body' | any, event: string,\n    callback: (event: any) => boolean | void): () => void {\n    if (typeof target === 'string') {\n      target = getGlobalEventTarget(target);\n      if (!target) {\n        throw new Error(`Unsupported event target ${target} for event ${event}`);\n      }\n    }\n    target.addEventListener(event, /** @type {?} */(( callback as any)), false);\n    return () => target.removeEventListener(event, /** @type {?} */(( callback as any)), false);\n  }\n}\nexport class ParseableDomRenderer extends DefaultDomRenderer {\n/**\n * @param {?} _visitor\n * @param {?} hostElement\n */\nconstructor(private _visitor: Visitor,\npublic hostElement: Node) {\n    super();\n  }\n/**\n * @param {?} context\n * @return {?}\n */\nparse(context: any) {\n    const /** @type {?} */ traverser = new DomTraverser();\n    traverser.traverse(this.hostElement, this._visitor, context);\n  }\n/**\n * @param {?} node\n * @return {?}\n */\ndestroyNode(node: any) {\n    if (node instanceof Node) {\n      this.removeChild(node.parentNode, node);\n    }\n  }\n}\n\nfunction ParseableDomRenderer_tsickle_Closure_declarations() {\n/** @type {?} */\nParseableDomRenderer.prototype._visitor;\n/** @type {?} */\nParseableDomRenderer.prototype.hostElement;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Visitor, ViewData } from 'mojiito-core';\nimport { DomVisitor } from './dom_visitor';\n\nexport interface Traverser {\n  traverse(node: any, visitor: Visitor, context: ViewData): void;\n}\nexport class DomTraverser implements Traverser {\nprivate _nodeCount = 0;\nprivate _elementCount = 0;\nprivate _attributeCount = 0;\nprivate _textCount = 0;\nprivate _commentCount = 0;\nconstructor() { }\n/**\n * @param {?} node\n * @param {?} visitor\n * @param {?=} context\n * @return {?}\n */\ntraverse(node: Node, visitor: Visitor, context: ViewData = null) {\n    let /** @type {?} */ lclCntxt: ViewData = context;\n    this._nodeCount++;\n\n    if (node instanceof Element) {\n      lclCntxt = visitor.visitElement(node, lclCntxt) || lclCntxt;\n      this._elementCount++;\n    } else if (node instanceof Text) {\n      lclCntxt = visitor.visitText(node, lclCntxt) || lclCntxt;\n      this._textCount++;\n    } else if (node instanceof Comment) {\n      lclCntxt = visitor.visitComment(node, lclCntxt) || lclCntxt;\n      this._commentCount++;\n    }\n\n    // Check if context has changed and look up the corresponding\n    // NodeVisitor if available\n    if (!!lclCntxt && lclCntxt !== context) {\n      let /** @type {?} */ rendererType = lclCntxt.def.componentRendererType;\n      if (rendererType) {\n        visitor = rendererType.visitor;\n      }\n    } else {\n      // Traverse through all the attributes of the node\n      // if it is type of Element\n      if (node instanceof Element && node.attributes.length) {\n        for (let /** @type {?} */ i = 0, /** @type {?} */ max = node.attributes.length; i < max; i++) {\n          lclCntxt = visitor.visitAttribute(node, node.attributes[i], lclCntxt) || lclCntxt;\n          this._attributeCount++;\n        }\n      }\n    }\n\n    // Start traversing the child nodes\n    let /** @type {?} */ childNode = node.firstChild;\n    if (childNode) {\n      this.traverse(childNode, visitor, lclCntxt);\n      while (childNode = childNode.nextSibling) {\n        this.traverse(childNode, visitor, lclCntxt);\n      }\n    }\n  }\n}\n\nfunction DomTraverser_tsickle_Closure_declarations() {\n/** @type {?} */\nDomTraverser.prototype._nodeCount;\n/** @type {?} */\nDomTraverser.prototype._elementCount;\n/** @type {?} */\nDomTraverser.prototype._attributeCount;\n/** @type {?} */\nDomTraverser.prototype._textCount;\n/** @type {?} */\nDomTraverser.prototype._commentCount;\n}\n\n","import { InjectionToken } from 'mojiito-core';\n\nexport const /** @type {?} */ DOCUMENT = new InjectionToken<Document>('DocumentToken');\n","import {\n  PlatformRef, Injectable, Injector, ClassType, ApplicationRef,\n  ComponentResolver, ReflectiveInjector, ComponentFactoryResolver\n} from 'mojiito-core';\nimport { Compiler } from './compiler/compiler';\nexport class BrowserPlatformRef extends PlatformRef {\nprivate _destroyed = false;\nprivate _destroyListeners: Function[] = [];\n/**\n * @param {?} _injector\n * @param {?} _resolver\n * @param {?} _compiler\n */\nconstructor(private _injector: Injector,\nprivate _resolver: ComponentResolver,\nprivate _compiler: Compiler) {\n    super();\n  }\n/**\n * @return {?}\n */\nget injector(): Injector { return this._injector; }\n/**\n * @return {?}\n */\nget destroyed(): boolean { return this._destroyed; }\n/**\n * @template C\n * @param {?} component\n * @return {?}\n */\nbootstrapComponent<C>(component: ClassType<C>): void {\n    this._compiler.compileComponents([component]);\n    const /** @type {?} */ appInjector = ReflectiveInjector.resolveAndCreate([\n      {\n        provide: ComponentFactoryResolver,\n        useFactory: () => this._compiler.createComponentFactoryResolver()\n      },\n      ApplicationRef\n    ], this._injector);\n\n    const /** @type {?} */ app = /** @type {?} */(( appInjector.get(ApplicationRef) as ApplicationRef));\n    app.bootstrap(component);\n  }\n/**\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: () => void): void {\n    this._destroyListeners.push(callback);\n  }\n/**\n * @return {?}\n */\ndestroy(): void {\n    if (this._destroyed) {\n      throw new Error('The platform has already been destroyed!');\n    }\n    // TODO: destroy all se stuff\n    this._destroyListeners.forEach(listener => listener());\n    this._destroyed = true;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Injector, },\n{type: ComponentResolver, },\n{type: Compiler, },\n];\n}\n\nfunction BrowserPlatformRef_tsickle_Closure_declarations() {\n/** @type {?} */\nBrowserPlatformRef.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nBrowserPlatformRef.ctorParameters;\n/** @type {?} */\nBrowserPlatformRef.prototype._destroyed;\n/** @type {?} */\nBrowserPlatformRef.prototype._destroyListeners;\n/** @type {?} */\nBrowserPlatformRef.prototype._injector;\n/** @type {?} */\nBrowserPlatformRef.prototype._resolver;\n/** @type {?} */\nBrowserPlatformRef.prototype._compiler;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  ClassType, Component, ComponentResolver, Injectable, Renderer, RendererType, ComponentRef,\n  ComponentFactory, ComponentFactoryResolver, createComponentFactory, resolveReflectiveProviders,\n  ElementRef, Injector, ApplicationRef, Provider, ReflectiveInjector, ReflectorReader,\n  HostListener, ChildListener, createViewDefinitionFactory, SkipSelf, NodeFlags, NodeDef,\n  ViewDefinitionFactory, ViewDefinition, DepFlags, constructDependencies, ProviderDef, DepDef,\n  Visitor\n} from 'mojiito-core';\nimport { ListWrapper } from '../facade/collection';\nimport { stringify } from '../facade/lang';\nimport { DomVisitor } from '../dom_visitor';\nimport { DomTraverser } from '../dom_traverser';\nimport { BindingParser, EventBindingParseResult } from '../binding_parser';\nimport { CompileComponentSummary } from './compile_result';\nexport class Compiler {\nprivate _compileResults = new Map<ClassType<any>, CompileComponentSummary>();\n/**\n * @param {?} _resolver\n * @param {?} _bindParser\n */\nconstructor(private _resolver: ComponentResolver,\nprivate _bindParser: BindingParser) { }\n/**\n * @return {?}\n */\ncreateComponentFactoryResolver() {\n    const /** @type {?} */ factories: ComponentFactory<any>[] = [];\n    this._compileResults.forEach(summary => {\n      factories.push(summary.componentFactory);\n    });\n    return new ComponentFactoryResolver(factories);\n  }\n/**\n * @param {?} components\n * @return {?}\n */\ncompileComponents(components: ClassType<any>[]): CompileComponentSummary[] {\n    return components.map(c => this.compileComponent(c));\n  }\n/**\n * @template C\n * @param {?} component\n * @return {?}\n */\ncompileComponent<C>(component: ClassType<C>): CompileComponentSummary {\n    let /** @type {?} */ compileSummary = this._compileResults.get(component);\n    if (compileSummary) {\n      return compileSummary;\n    }\n\n    // grab component metadata\n    const /** @type {?} */ metadata = this._resolver.resolve(component);\n\n    // compile child components\n    let /** @type {?} */ childComponents: CompileComponentSummary[];\n    let /** @type {?} */ rendererType: RendererType;\n    if (metadata.components) {\n      childComponents = this.compileComponents(ListWrapper.flatten(metadata.components));\n\n      // create a renderer type with a visitor for this component with all\n      // sub components\n      rendererType = this._createComponentRendererType(new DomVisitor(childComponents));\n    }\n\n    // create a view definition factory for this component type\n    const /** @type {?} */ viewDefinitionFactory =\n      this._createComponentViewDef(component, metadata.providers, rendererType);\n\n    // create a component factory for this component type\n    const /** @type {?} */ componentFactory =\n      createComponentFactory(metadata.selector, component, viewDefinitionFactory);\n\n    compileSummary = {\n      type: component,\n      selector: metadata.selector,\n      hostListeners: metadata.host,\n      childListeners: metadata.childs,\n      componentFactory,\n      viewDefinitionFactory,\n      components: childComponents\n    };\n    this._compileResults.set(component, compileSummary);\n    return compileSummary;\n  }\n/**\n * @param {?} providers\n * @param {?} nodes\n * @param {?} nodeType\n * @return {?}\n */\nprivate _createProviderNodes(providers: Provider[], nodes: NodeDef[],\n    nodeType: NodeFlags): NodeDef[] {\n    const /** @type {?} */ nodeDefs = resolveReflectiveProviders(ListWrapper.flatten(providers))\n      .map((provider, index) => {\n        const /** @type {?} */ factory = provider.resolvedFactories[0];\n        const /** @type {?} */ node = /** @type {?} */(( <NodeDef>{\n          flags: nodeType,\n          index: nodes.length + index,\n          provider: /** @type {?} */(( <ProviderDef>{\n            token: provider.key.token,\n            tokenKey: provider.key.displayName,\n            factory: factory.factory,\n            deps: factory.dependencies.map(dep => {\n              let /** @type {?} */ flags = 0;\n              if (dep.optional) {\n                flags += DepFlags.Optional;\n              }\n              if (dep.visibility instanceof SkipSelf) {\n                flags += DepFlags.SkipSelf;\n              }\n              return /** @type {?} */(( <DepDef>{\n                flags,\n                token: dep.key.token,\n                tokenKey: dep.key.displayName\n              }));\n            })\n          }))\n        }));\n        return node;\n      });\n    nodes.push(...nodeDefs);\n    return nodeDefs;\n  }\n/**\n * @param {?} visitor\n * @return {?}\n */\nprivate _createComponentRendererType(visitor: Visitor): RendererType {\n    return {\n      visitor,\n      data: null\n    };\n  }\n/**\n * @param {?} component\n * @param {?} providers\n * @param {?} componentRendererType\n * @return {?}\n */\nprivate _createComponentViewDef(component: ClassType<any>, providers: Provider[],\n      componentRendererType: RendererType): ViewDefinitionFactory {\n    const /** @type {?} */ viewDefinitionFactory: ViewDefinitionFactory = () => {\n      const /** @type {?} */ nodes: NodeDef[] = [];\n      let /** @type {?} */ nodeFlags = NodeFlags.ComponentView;\n\n      // Create public provider instances and add to nodes\n      let /** @type {?} */ publicProviders: {[key: string]: NodeDef} = {};\n      if (providers) {\n        this._createProviderNodes(providers, nodes, NodeFlags.TypeProvider).forEach(node => {\n          publicProviders[node.provider.tokenKey] = node;\n        });\n        nodeFlags |= NodeFlags.TypeProvider;\n      }\n\n      // Create component instance and add to nodes\n      this._createProviderNodes([component], nodes, NodeFlags.TypeComponent);\n      const /** @type {?} */ componentProvider = nodes[nodes.length - 1];\n      nodeFlags |= NodeFlags.TypeComponent;\n\n      // Set allProviders to publicProviders plus private providers (componentProvider)\n      const /** @type {?} */ allProviders = publicProviders;\n      allProviders[componentProvider.provider.tokenKey] = componentProvider;\n\n      return /** @type {?} */(( <ViewDefinition>{\n        factory: viewDefinitionFactory,\n        nodeFlags,\n        nodes,\n        componentProvider,\n        publicProviders,\n        allProviders,\n        componentRendererType\n      }));\n    };\n    return viewDefinitionFactory;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ComponentResolver, },\n{type: BindingParser, },\n];\n}\n\nfunction Compiler_tsickle_Closure_declarations() {\n/** @type {?} */\nCompiler.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nCompiler.ctorParameters;\n/** @type {?} */\nCompiler.prototype._compileResults;\n/** @type {?} */\nCompiler.prototype._resolver;\n/** @type {?} */\nCompiler.prototype._bindParser;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Injectable } from 'mojiito-core';\nimport { Expression, ExpressionParser } from './expression/expression';\nimport { isPresent } from './facade/lang';\n\n// tslint:disable-next-line:max-line-length\nconst /** @type {?} */ BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n\n// Group 1 = \"bind-\"\nconst /** @type {?} */ KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst /** @type {?} */ KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst /** @type {?} */ KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst /** @type {?} */ KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst /** @type {?} */ KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst /** @type {?} */ KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst /** @type {?} */ IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nconst /** @type {?} */ IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nconst /** @type {?} */ IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nconst /** @type {?} */ IDENT_EVENT_IDX = 10;\n\nconst /** @type {?} */ CLASS_ATTR = 'class';\nexport class BindingParser {\n/**\n * @param {?} _exprParser\n */\nconstructor(private _exprParser: ExpressionParser) { }\n/**\n * @param {?} name\n * @param {?} expression\n * @return {?}\n */\nparse(name: string, expression: string) {\n    const /** @type {?} */ bindParts = name.match(BIND_NAME_REGEXP);\n    const /** @type {?} */ expr = this._exprParser.parse(expression);\n    let /** @type {?} */ key: string;\n\n    if (isPresent(bindParts[KW_BIND_IDX])) {\n      unsupported('Property binding', name, expression);\n    } else if (bindParts[KW_REF_IDX]) {\n      unsupported('Variable declaration', name, expression);\n    } else if (bindParts[KW_ON_IDX]) {\n      return new EventBindingParseResult(bindParts[IDENT_KW_IDX], expr);\n    } else if (bindParts[KW_BINDON_IDX]) {\n      unsupported('Two way binding', name, expression);\n    } else if (bindParts[KW_AT_IDX]) {\n      unsupported('Animations', name, expression);\n    } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n      unsupported('Two way binding', name, expression);\n    } else if (bindParts[IDENT_PROPERTY_IDX]) {\n      unsupported('Property binding', name, expression);\n    } else if (bindParts[IDENT_EVENT_IDX]) {\n      return new EventBindingParseResult(bindParts[IDENT_EVENT_IDX], expr);\n    } else {\n      throw new Error(`Unknown binding name: ${name}`);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ExpressionParser, },\n];\n}\n\nfunction BindingParser_tsickle_Closure_declarations() {\n/** @type {?} */\nBindingParser.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nBindingParser.ctorParameters;\n/** @type {?} */\nBindingParser.prototype._exprParser;\n}\n\nexport class BindingParseResult {\n/**\n * @param {?} expression\n */\nconstructor(public expression: Expression) { }\n}\n\nfunction BindingParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nBindingParseResult.prototype.expression;\n}\n\nexport class EventBindingParseResult extends BindingParseResult {\n/**\n * @param {?} eventName\n * @param {?} expression\n */\nconstructor(public eventName: string, expression: Expression) {\n    super(expression);\n  }\n}\n\nfunction EventBindingParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nEventBindingParseResult.prototype.eventName;\n}\n\n/**\n * @param {?} type\n * @param {?} name\n * @param {?} expression\n * @return {?}\n */\nfunction unsupported(type: string, name: string, expression: string) {\n  throw new Error(`${type} is not yet supported: ${name}=\"${expression}\"`);\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Token, ExpressionParser } from './expression_parser';\n\nexport { Token, ExpressionParser };\nexport class Expression {\n/**\n * @param {?} tokens\n */\nconstructor(public tokens: Token[]) { }\n}\n\nfunction Expression_tsickle_Closure_declarations() {\n/** @type {?} */\nExpression.prototype.tokens;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport { Injectable } from 'mojiito-core';\nimport * as chars from '../chars';\nimport { NumberWrapper } from '../facade/lang';\nimport { Expression } from './expression';\nexport type TokenType = number;\nexport let TokenType: any = {};\nTokenType.Character = 0;\nTokenType.Identifier = 1;\nTokenType.Keyword = 2;\nTokenType.String = 3;\nTokenType.Operator = 4;\nTokenType.Number = 5;\nTokenType.Error = 6;\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\n\n\nconst /** @type {?} */ KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nexport class ExpressionParser {\n/**\n * @param {?} text\n * @return {?}\n */\ntokenize(text: string): Token[] {\n    const /** @type {?} */ scanner = new Scanner(text);\n    const /** @type {?} */ tokens: Token[] = [];\n    let /** @type {?} */ token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n/**\n * @param {?} text\n * @return {?}\n */\nparse(text: string): Expression {\n    return new Expression(this.tokenize(text));\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ExpressionParser_tsickle_Closure_declarations() {\n/** @type {?} */\nExpressionParser.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nExpressionParser.ctorParameters;\n}\n\nexport class Token {\n/**\n * @param {?} index\n * @param {?} type\n * @param {?} numValue\n * @param {?} strValue\n */\nconstructor(\npublic index: number,\npublic type: TokenType,\npublic numValue: number,\npublic strValue: string) { }\n/**\n * @param {?} code\n * @return {?}\n */\nisCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n/**\n * @return {?}\n */\nisNumber(): boolean { return this.type == TokenType.Number; }\n/**\n * @return {?}\n */\nisString(): boolean { return this.type == TokenType.String; }\n/**\n * @param {?} operater\n * @return {?}\n */\nisOperator(operater: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operater;\n  }\n/**\n * @return {?}\n */\nisIdentifier(): boolean { return this.type == TokenType.Identifier; }\n/**\n * @return {?}\n */\nisKeyword(): boolean { return this.type == TokenType.Keyword; }\n/**\n * @return {?}\n */\nisKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n/**\n * @return {?}\n */\nisKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n/**\n * @return {?}\n */\nisKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n/**\n * @return {?}\n */\nisKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n/**\n * @return {?}\n */\nisKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n/**\n * @return {?}\n */\nisKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n/**\n * @return {?}\n */\nisError(): boolean { return this.type == TokenType.Error; }\n/**\n * @return {?}\n */\ntoNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n/**\n * @return {?}\n */\ntoString(): string {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction Token_tsickle_Closure_declarations() {\n/** @type {?} */\nToken.prototype.index;\n/** @type {?} */\nToken.prototype.type;\n/** @type {?} */\nToken.prototype.numValue;\n/** @type {?} */\nToken.prototype.strValue;\n}\n\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const /** @type {?} */ EOF: Token = new Token(-1, TokenType.Character, 0, '');\nclass Scanner {\n  length: number;\n  peek = 0;\n  index = -1;\n/**\n * @param {?} input\n */\nconstructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n/**\n * @return {?}\n */\nadvance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n/**\n * @return {?}\n */\nscanToken(): Token {\n    const /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n    let /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const /** @type {?} */ start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n          newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n          start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n/**\n * @param {?} start\n * @param {?} code\n * @return {?}\n */\nscanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n/**\n * @param {?} start\n * @param {?} str\n * @return {?}\n */\nscanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n/**\n * Tokenize a 2/3 char long operator\n * \n * @param {?} start start index in the expression\n * @param {?} one first symbol (always part of the operator)\n * @param {?} twoCode code point for the second symbol\n * @param {?} two second symbol (part of the operator when the second code point matches)\n * @param {?=} threeCode code point for the third symbol\n * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n * @return {?}\n */\nscanComplexOperator(\n    start: number, one: string, twoCode: number, two: string, threeCode?: number,\n    three?: string): Token {\n    this.advance();\n    let /** @type {?} */ str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n/**\n * @return {?}\n */\nscanIdentifier(): Token {\n    const /** @type {?} */ start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n      newIdentifierToken(start, str);\n  }\n/**\n * @param {?} start\n * @return {?}\n */\nscanNumber(start: number): Token {\n    let /** @type {?} */ simple: boolean = (this.index === start);\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek == chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    const /** @type {?} */ value: number = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n/**\n * @return {?}\n */\nscanString(): Token {\n    const /** @type {?} */ start = this.index;\n    const /** @type {?} */ quote = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let /** @type {?} */ buffer = '';\n    let /** @type {?} */ marker = this.index;\n    const /** @type {?} */ input = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let /** @type {?} */ unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const /** @type {?} */ hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let /** @type {?} */ i = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const /** @type {?} */ last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n/**\n * @param {?} message\n * @param {?} offset\n * @return {?}\n */\nerror(message: string, offset: number): Token {\n    const /** @type {?} */ position: number = this.index + offset;\n    return newErrorToken(\n      position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction Scanner_tsickle_Closure_declarations() {\n/** @type {?} */\nScanner.prototype.length;\n/** @type {?} */\nScanner.prototype.peek;\n/** @type {?} */\nScanner.prototype.index;\n/** @type {?} */\nScanner.prototype.input;\n}\n\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n    (code == chars.$_) || (code == chars.$$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const /** @type {?} */ scanner = new Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n    (code == chars.$$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport const $EOF = 0;\nexport const /** @type {?} */ $TAB = 9;\nexport const /** @type {?} */ $LF = 10;\nexport const /** @type {?} */ $VTAB = 11;\nexport const /** @type {?} */ $FF = 12;\nexport const /** @type {?} */ $CR = 13;\nexport const /** @type {?} */ $SPACE = 32;\nexport const /** @type {?} */ $BANG = 33;\nexport const /** @type {?} */ $DQ = 34;\nexport const /** @type {?} */ $HASH = 35;\nexport const /** @type {?} */ $$ = 36;\nexport const /** @type {?} */ $PERCENT = 37;\nexport const /** @type {?} */ $AMPERSAND = 38;\nexport const /** @type {?} */ $SQ = 39;\nexport const /** @type {?} */ $LPAREN = 40;\nexport const /** @type {?} */ $RPAREN = 41;\nexport const /** @type {?} */ $STAR = 42;\nexport const /** @type {?} */ $PLUS = 43;\nexport const /** @type {?} */ $COMMA = 44;\nexport const /** @type {?} */ $MINUS = 45;\nexport const /** @type {?} */ $PERIOD = 46;\nexport const /** @type {?} */ $SLASH = 47;\nexport const /** @type {?} */ $COLON = 58;\nexport const /** @type {?} */ $SEMICOLON = 59;\nexport const /** @type {?} */ $LT = 60;\nexport const /** @type {?} */ $EQ = 61;\nexport const /** @type {?} */ $GT = 62;\nexport const /** @type {?} */ $QUESTION = 63;\n\nexport const /** @type {?} */ $0 = 48;\nexport const /** @type {?} */ $9 = 57;\n\nexport const /** @type {?} */ $A = 65;\nexport const /** @type {?} */ $E = 69;\nexport const /** @type {?} */ $F = 70;\nexport const /** @type {?} */ $X = 88;\nexport const /** @type {?} */ $Z = 90;\n\nexport const /** @type {?} */ $LBRACKET = 91;\nexport const /** @type {?} */ $BACKSLASH = 92;\nexport const /** @type {?} */ $RBRACKET = 93;\nexport const /** @type {?} */ $CARET = 94;\nexport const /** @type {?} */ $_ = 95;\n\nexport const /** @type {?} */ $a = 97;\nexport const /** @type {?} */ $e = 101;\nexport const /** @type {?} */ $f = 102;\nexport const /** @type {?} */ $n = 110;\nexport const /** @type {?} */ $r = 114;\nexport const /** @type {?} */ $t = 116;\nexport const /** @type {?} */ $u = 117;\nexport const /** @type {?} */ $v = 118;\nexport const /** @type {?} */ $x = 120;\nexport const /** @type {?} */ $z = 122;\n\nexport const /** @type {?} */ $LBRACE = 123;\nexport const /** @type {?} */ $BAR = 124;\nexport const /** @type {?} */ $RBRACE = 125;\nexport const /** @type {?} */ $NBSP = 160;\n\nexport const /** @type {?} */ $PIPE = 124;\nexport const /** @type {?} */ $TILDA = 126;\nexport const /** @type {?} */ $AT = 64;\n\nexport const /** @type {?} */ $BT = 96;\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isAsciiLetter(code: number): boolean {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isAsciiHexDigit(code: number): boolean {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n","import { CssSelector, SelectorMatcher } from './selector';\nimport { ClassType, Visitor, createView, ViewData } from 'mojiito-core';\nimport { WrappedError } from './facade/error';\nimport { stringify } from './facade/lang';\nimport { ListWrapper } from './facade/collection';\nimport { CompileComponentSummary } from './compiler/compile_result';\nexport class DomVisitor implements Visitor {\nprivate _selectorMatcher = new SelectorMatcher();\nprivate _componentsIndex = new Map<CompileComponentSummary, number>();\n/**\n * @param {?} components\n */\nconstructor(components: CompileComponentSummary[]) {\n    components.forEach((component, index) => {\n      const selector = CssSelector.parse(component.selector);\n      this._selectorMatcher.addSelectables(selector, component);\n      this._componentsIndex.set(component, index);\n    });\n  }\n/**\n * @param {?} element\n * @param {?} context\n * @return {?}\n */\nvisitElement(element: Element, context: ViewData): any {\n    const /** @type {?} */ elementCssSelector = CssSelector.fromElement(element);\n    let /** @type {?} */ matchingComponent: CompileComponentSummary;\n    this._selectorMatcher.match(elementCssSelector, (selector, component) => {\n      if (matchingComponent) {\n        throw new MultipleComponentsOnElementError([matchingComponent.type, component.type]);\n      }\n      matchingComponent = component;\n    });\n\n    // if no matching component return current context\n    if (!matchingComponent) {\n      return context;\n    }\n\n    // console.log(`Found ${stringify(matchingComponent.type)} on element:`, element);\n\n    const /** @type {?} */ viewDef = matchingComponent.viewDefinitionFactory();\n    const /** @type {?} */ view = createView(context.root, context, element, viewDef);\n\n    // console.log(`Created ${stringify(matchingComponent.type)} ` +\n    //   `with parent ${stringify(context.component.constructor)}`);\n\n    ListWrapper.forEach(element.attributes, attr => {\n\n    });\n\n    return view;\n  }\n/**\n * @param {?} element\n * @param {?} attr\n * @param {?} context\n * @return {?}\n */\nvisitAttribute(element: Element, attr: Attr, context: any) { }\n/**\n * @param {?} text\n * @param {?} context\n * @return {?}\n */\nvisitText(text: Text, context: any) { }\n/**\n * @param {?} comment\n * @param {?} context\n * @return {?}\n */\nvisitComment(comment: Comment, context: any) { }\n\n}\n\nfunction DomVisitor_tsickle_Closure_declarations() {\n/** @type {?} */\nDomVisitor.prototype._selectorMatcher;\n/** @type {?} */\nDomVisitor.prototype._componentsIndex;\n}\n\nexport class ParseError extends WrappedError {\n/**\n * @param {?} error\n */\nconstructor(error: any) {\n    super(`Parse Error`, error);\n  }\n}\nexport class MultipleComponentsOnElementError extends ParseError {\n/**\n * @param {?} components\n */\nconstructor(components: ClassType<any>[]) {\n    const names = components.map(c => stringify(c)).join(', ');\n    super(`The selectors of the components ${names} are matching the same DOM Element. ` +\n      `Only one component per element is allowed.`);\n  }\n}\n","\n/**\n * Returns the class name of a type.\n * \n * @export\n * @template T\n * @param {?} klass\n * @return {?}\n */\nexport function getClassName<T>(klass: Function) {\n  return ( /** @type {?} */((klass as any))).name ? ( /** @type {?} */((klass as any))).name :\n    /^function\\s+([\\w\\$]+)\\s*\\(/.exec(this.toString())[1];\n}\n/**\n * Tries to stringify a token. A token can be any type.\n * \n * @export\n * @param {?} token\n * @return {?}\n */\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (token === undefined || token === null) {\n    return '' + token;\n  }\n  if (token.name) {\n    return token.name;\n  }\n  if (token.overriddenName) {\n    return token.overriddenName;\n  }\n  if (typeof token === 'function') {\n      return getClassName(token);\n  }\n  if (token instanceof HTMLElement) {\n    let /** @type {?} */ parts = token.toString().match(/\\w+/g);\n    if (parts && parts.length) {\n      return parts[parts.length - 1];\n    }\n  }\n\n  var /** @type {?} */ res = token.toString();\n  var /** @type {?} */ newLineIndex = res.indexOf('\\n');\n  return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);\n}\n\nexport interface BrowserNodeGlobal {\n  Object: typeof Object;\n  Array: typeof Array;\n  Map: typeof Map;\n  Set: typeof Set;\n  Date: DateConstructor;\n  RegExp: RegExpConstructor;\n  JSON: typeof JSON;\n  Math: any;  // typeof Math;\n  assert(condition: any): void;\n  Reflect: any;\n  setTimeout: Function;\n  clearTimeout: Function;\n  setInterval: Function;\n  clearInterval: Function;\n  encodeURI: Function;\n}\n\ndeclare var WorkerGlobalScope: any;\ndeclare var global: any;\nlet /** @type {?} */ globalScope: BrowserNodeGlobal;\nif (typeof window === 'undefined') {\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n    // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n    globalScope = /** @type {?} */(( <any>self));\n  } else {\n    globalScope = /** @type {?} */(( <any>global));\n  }\n} else {\n  globalScope = /** @type {?} */(( <any>window));\n}\nexport {globalScope as global};\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isPresent(obj: any): boolean {\n  return obj != null;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isBlank(obj: any): boolean {\n  return obj == null;\n}\nexport class NumberWrapper {\n/**\n * @param {?} text\n * @return {?}\n */\nstatic parseIntAutoRadix(text: string): number {\n    const /** @type {?} */ result: number = parseInt(text);\n    if (isNaN(result)) {\n      throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n  }\n/**\n * @param {?} value\n * @return {?}\n */\nstatic isNumeric(value: any): boolean { return !isNaN(value - parseFloat(value)); }\n}\n","\n/**\n * Convenience to throw an Error with 'unimplemented' as the message.\n * @return {?}\n */\nexport function unimplemented(): any {\n  throw new Error('unimplemented');\n}\nexport class BaseError extends Error {\n/**\n * \\@internal *\n */\n_nativeError: Error;\n/**\n * @param {?} message\n */\nconstructor(message: string) {\n    super(message);\n    // Errors don't use current this, instead they create a new instance.\n    // We have to do forward all of our api to the nativeInstance.\n    const nativeError = new Error(message) as any as Error;\n    this._nativeError = nativeError;\n  }\n/**\n * @return {?}\n */\nget message() { return this._nativeError.message; }\n/**\n * @param {?} message\n * @return {?}\n */\nset message(message) { this._nativeError.message = message; }\n/**\n * @return {?}\n */\nget name() { return this._nativeError.name; }\n/**\n * @return {?}\n */\nget stack() { return ( /** @type {?} */((this._nativeError as any))).stack; }\n/**\n * @param {?} value\n * @return {?}\n */\nset stack(value) { ( /** @type {?} */((this._nativeError as any))).stack = value; }\n/**\n * @return {?}\n */\ntoString() { return this._nativeError.toString(); }\n}\n\nfunction BaseError_tsickle_Closure_declarations() {\n/**\n * \\@internal *\n * @type {?}\n */\nBaseError.prototype._nativeError;\n}\n\nexport class WrappedError extends BaseError {\n  originalError: any;\n/**\n * @param {?} message\n * @param {?} error\n */\nconstructor(message: string, error: any) {\n    super(`${message} caused by: ${error instanceof Error ? error.message : error}`);\n    this.originalError = error;\n  }\n/**\n * @return {?}\n */\nget stack() {\n    return ( /** @type {?} */(((this.originalError instanceof Error ? this.originalError : this._nativeError) as any)))\n      .stack;\n  }\n}\n\nfunction WrappedError_tsickle_Closure_declarations() {\n/** @type {?} */\nWrappedError.prototype.originalError;\n}\n\n","import { ListWrapper } from './facade/collection';\n\nconst /** @type {?} */ _SELECTOR_REGEXP = new RegExp(\n  '(\\\\:not\\\\()|' +           // \":not(\"\n  '([-\\\\w]+)|' +         // \"tag\"\n  '(?:\\\\.([-\\\\w]+))|' +  // \".class\"\n  // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n  '(?:\\\\[([-.\\\\w*]+)(?:=([^\\\\]]*))?\\\\])|' +  // \"[name]\", \"[name=value]\"\n  '(\\\\))|' +                                 // \")\"\n  '(\\\\s*,\\\\s*)',                             // \",\"\n  'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string = null;\n  classNames: string[] = [];\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n/**\n * @param {?} element\n * @return {?}\n */\nstatic fromElement(element: Element): CssSelector {\n    const /** @type {?} */ selector = new CssSelector();\n    selector.setElement(element.tagName.toLocaleLowerCase());\n    ListWrapper.forEach(element.attributes, (attr: Attr) => {\n      if (attr.name.toLocaleLowerCase() !== 'class') {\n        selector.addAttribute(attr.name.trim(), attr.value.trim());\n      }\n    });\n    ListWrapper.forEach(element.classList, (c: string) => selector.addClassName(c));\n    return selector;\n  }\n/**\n * @param {?} selector\n * @return {?}\n */\nstatic parse(selector: string): CssSelector[] {\n    const /** @type {?} */ results: CssSelector[] = [];\n    const /** @type {?} */ _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n        cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let /** @type {?} */ cssSelector = new CssSelector();\n    let /** @type {?} */ match: string[];\n    let /** @type {?} */ current = cssSelector;\n    let /** @type {?} */ inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[1]) {\n        if (inNot) {\n          throw new Error('Nesting :not is not allowed in a selector');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      if (match[2]) {\n        current.setElement(match[2]);\n      }\n      if (match[3]) {\n        current.addClassName(match[3]);\n      }\n      if (match[4]) {\n        current.addAttribute(match[4], match[5]);\n      }\n      if (match[6]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[7]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n/**\n * @return {?}\n */\nisElementSelector(): boolean {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n      this.notSelectors.length === 0;\n  }\n/**\n * @return {?}\n */\nhasElementSelector(): boolean { return !!this.element; }\n/**\n * @param {?=} element\n * @return {?}\n */\nsetElement(element: string = null) { this.element = element; }\n/**\n * @param {?} name\n * @param {?=} value\n * @return {?}\n */\naddAttribute(name: string, value = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n/**\n * @param {?} name\n * @return {?}\n */\naddClassName(name: string) { this.classNames.push(name.toLowerCase()); }\n/**\n * @return {?}\n */\ntoString(): string {\n    let /** @type {?} */ res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n        const /** @type {?} */ name = this.attrs[i];\n        const /** @type {?} */ value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\n\nfunction CssSelector_tsickle_Closure_declarations() {\n/** @type {?} */\nCssSelector.prototype.element;\n/** @type {?} */\nCssSelector.prototype.classNames;\n/** @type {?} */\nCssSelector.prototype.attrs;\n/** @type {?} */\nCssSelector.prototype.notSelectors;\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher {\n/**\n * @param {?} notSelectors\n * @return {?}\n */\nstatic createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher {\n    const /** @type {?} */ notMatcher = new SelectorMatcher();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\nprivate _elementMap = new Map<string, SelectorContext[]>();\nprivate _elementPartialMap = new Map<string, SelectorMatcher>();\nprivate _classMap = new Map<string, SelectorContext[]>();\nprivate _classPartialMap = new Map<string, SelectorMatcher>();\nprivate _attrValueMap = new Map<string, Map<string, SelectorContext[]>>();\nprivate _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher>>();\nprivate _listContexts: SelectorListContext[] = [];\n/**\n * @param {?} cssSelectors\n * @param {?=} callbackCtxt\n * @return {?}\n */\naddSelectables(cssSelectors: CssSelector[], callbackCtxt?: any) {\n    let /** @type {?} */ listContext: SelectorListContext = null;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let /** @type {?} */ i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n    }\n  }\n/**\n * Add an object that can be found later on by calling `match`.\n * @param {?} cssSelector A css selector\n * @param {?} callbackCtxt An opaque object that will be given to the callback of the `match` function\n * @param {?} listContext\n * @return {?}\n */\nprivate _addSelectable(\n    cssSelector: CssSelector, callbackCtxt: any, listContext: SelectorListContext) {\n    let /** @type {?} */ matcher: SelectorMatcher = this;\n    const /** @type {?} */ element = cssSelector.element;\n    const /** @type {?} */ classNames = cssSelector.classNames;\n    const /** @type {?} */ attrs = cssSelector.attrs;\n    const /** @type {?} */ selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const /** @type {?} */ isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let /** @type {?} */ i = 0; i < classNames.length; i++) {\n        const /** @type {?} */ isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const /** @type {?} */ className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n        const /** @type {?} */ isTerminal = i === attrs.length - 2;\n        const /** @type {?} */ name = attrs[i];\n        const /** @type {?} */ value = attrs[i + 1];\n        if (isTerminal) {\n          const /** @type {?} */ terminalMap = matcher._attrValueMap;\n          let /** @type {?} */ terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const /** @type {?} */ partialMap = matcher._attrValuePartialMap;\n          let /** @type {?} */ partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n/**\n * @param {?} map\n * @param {?} name\n * @param {?} selectable\n * @return {?}\n */\nprivate _addTerminal(\n    map: Map<string, SelectorContext[]>, name: string, selectable: SelectorContext) {\n    let /** @type {?} */ terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n/**\n * @param {?} map\n * @param {?} name\n * @return {?}\n */\nprivate _addPartial(map: Map<string, SelectorMatcher>, name: string): SelectorMatcher {\n    let /** @type {?} */ matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n/**\n * Find the objects that have been added via `addSelectable`\n * whose css selector is contained in the given css selector.\n * @param {?} cssSelector A css selector\n * @param {?=} matchedCallback This callback will be called with the object handed into `addSelectable`\n * @return {?} boolean true if a match was found\n */\nmatch(cssSelector: CssSelector,\n    matchedCallback: (c: CssSelector, a: any) => void = function () { }): boolean {\n    let /** @type {?} */ result = false;\n    const /** @type {?} */ element = cssSelector.element;\n    const /** @type {?} */ classNames = cssSelector.classNames;\n    const /** @type {?} */ attrs = cssSelector.attrs;\n\n    for (let /** @type {?} */ i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n      result;\n\n    if (classNames) {\n      for (let /** @type {?} */ i = 0; i < classNames.length; i++) {\n        const /** @type {?} */ className = classNames[i];\n        result =\n          this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n          this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n          result;\n      }\n    }\n\n    if (attrs) {\n      for (let /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n        const /** @type {?} */ name = attrs[i];\n        const /** @type {?} */ value = attrs[i + 1];\n\n        const /** @type {?} */ terminalValuesMap = this._attrValueMap.get(name);\n        if (value) {\n          result =\n            this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const /** @type {?} */ partialValuesMap = this._attrValuePartialMap.get(name);\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n/**\n * \\@internal\n * @param {?} map\n * @param {?} name\n * @param {?} cssSelector\n * @param {?} matchedCallback\n * @return {?}\n */\n_matchTerminal(\n    map: Map<string, SelectorContext[]>, name: string, cssSelector: CssSelector,\n    matchedCallback: (c: CssSelector, a: any) => void): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let /** @type {?} */ selectables: SelectorContext[] = map.get(name) || [];\n    const /** @type {?} */ starSelectables: SelectorContext[] = map.get('*');\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let /** @type {?} */ selectable: SelectorContext;\n    let /** @type {?} */ result = false;\n    for (let /** @type {?} */ i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n/**\n * \\@internal\n * @param {?} map\n * @param {?} name\n * @param {?} cssSelector\n * @param {?} matchedCallback\n * @return {?}\n */\n_matchPartial(\n    map: Map<string, SelectorMatcher>, name: string, cssSelector: CssSelector,\n    matchedCallback: (c: CssSelector, a: any) => void): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const /** @type {?} */ nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\nfunction SelectorMatcher_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectorMatcher.prototype._elementMap;\n/** @type {?} */\nSelectorMatcher.prototype._elementPartialMap;\n/** @type {?} */\nSelectorMatcher.prototype._classMap;\n/** @type {?} */\nSelectorMatcher.prototype._classPartialMap;\n/** @type {?} */\nSelectorMatcher.prototype._attrValueMap;\n/** @type {?} */\nSelectorMatcher.prototype._attrValuePartialMap;\n/** @type {?} */\nSelectorMatcher.prototype._listContexts;\n}\n\nexport class SelectorListContext {\n  alreadyMatched = false;\n/**\n * @param {?} selectors\n */\nconstructor(public selectors: CssSelector[]) { }\n}\n\nfunction SelectorListContext_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectorListContext.prototype.alreadyMatched;\n/** @type {?} */\nSelectorListContext.prototype.selectors;\n}\n\nexport class SelectorContext {\n  notSelectors: CssSelector[];\n/**\n * @param {?} selector\n * @param {?} cbContext\n * @param {?} listContext\n */\nconstructor(\npublic selector: CssSelector,\npublic cbContext: any,\npublic listContext: SelectorListContext) {\n    this.notSelectors = selector.notSelectors;\n  }\n/**\n * @param {?} cssSelector\n * @param {?} callback\n * @return {?}\n */\nfinalize(cssSelector: CssSelector, callback: (c: CssSelector, a: any) => void): boolean {\n    let /** @type {?} */ result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const /** @type {?} */ notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n\nfunction SelectorContext_tsickle_Closure_declarations() {\n/** @type {?} */\nSelectorContext.prototype.notSelectors;\n/** @type {?} */\nSelectorContext.prototype.selector;\n/** @type {?} */\nSelectorContext.prototype.cbContext;\n/** @type {?} */\nSelectorContext.prototype.listContext;\n}\n\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport class StringMapWrapper {\n/**\n * @template V\n * @param {?} m1\n * @param {?} m2\n * @return {?}\n */\nstatic merge<V>(m1: {[key: string]: V}, m2: {[key: string]: V}): {[key: string]: V} {\n    const /** @type {?} */ m: {[key: string]: V} = {};\n\n    for (const /** @type {?} */ k of Object.keys(m1)) {\n      m[k] = m1[k];\n    }\n\n    for (const /** @type {?} */ k of Object.keys(m2)) {\n      m[k] = m2[k];\n    }\n\n    return m;\n  }\n/**\n * @template V\n * @param {?} m1\n * @param {?} m2\n * @return {?}\n */\nstatic equals<V>(m1: {[key: string]: V}, m2: {[key: string]: V}): boolean {\n    const /** @type {?} */ k1 = Object.keys(m1);\n    const /** @type {?} */ k2 = Object.keys(m2);\n\n    if (k1.length != k2.length) {\n      return false;\n    }\n\n    for (let /** @type {?} */ i = 0; i < k1.length; i++) {\n      const /** @type {?} */ key = k1[i];\n      if (m1[key] !== m2[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\nexport class ListWrapper {\n/**\n * @template T\n * @param {?} arr\n * @param {?} condition\n * @return {?}\n */\nstatic findLast<T>(arr: T[], condition: (value: T) => boolean): T {\n    for (let /** @type {?} */ i = arr.length - 1; i >= 0; i--) {\n      if (condition(arr[i])) {\n        return arr[i];\n      }\n    }\n    return null;\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} items\n * @return {?}\n */\nstatic removeAll<T>(list: T[], items: T[]) {\n    for (let /** @type {?} */ i = 0; i < items.length; ++i) {\n      const /** @type {?} */ index = list.indexOf(items[i]);\n      if (index > -1) {\n        list.splice(index, 1);\n      }\n    }\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} el\n * @return {?}\n */\nstatic remove<T>(list: T[], el: T): boolean {\n    const /** @type {?} */ index = list.indexOf(el);\n    if (index > -1) {\n      list.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nstatic equals(a: any[], b: any[]): boolean {\n    if (a.length != b.length) return false;\n    for (let /** @type {?} */ i = 0; i < a.length; ++i) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n/**\n * @template T\n * @param {?} list\n * @return {?}\n */\nstatic flatten<T>(list: Array<T | T[]>): T[] {\n    return list.reduce((flat: any[], item: T | T[]): T[] => {\n      const /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;\n      return ( /** @type {?} */((<T[]>flat))).concat(flatItem);\n    }, []);\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} callback\n * @return {?}\n */\nstatic forEach<T>(list: ArrayLike<T>, callback: (item: T, index: number) => void): void {\n    for (let /** @type {?} */ i = 0, /** @type {?} */ max = list.length; i < max; i++) {\n      callback.call(callback, list[i], i);\n    }\n  }\n}\n"],"names":["RendererFactory","PlatformRef","ExpressionParser","Injectable","InjectionToken","Injector","ComponentFactoryResolver","ReflectiveInjector","SkipSelf","resolveReflectiveProviders","createComponentFactory","chars.$EOF","chars.$BAR","chars.$AMPERSAND","chars.$BANG","chars.$GT","chars.$LT","chars.$QUESTION","chars.$CARET","chars.$PERCENT","chars.$STAR","chars.$MINUS","chars.$HASH","chars.$DQ","chars.$SQ","chars.$SEMICOLON","chars.$COLON","chars.$COMMA","chars.$RBRACKET","chars.$RPAREN","chars.$PERIOD","chars.isDigit","createView"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IegEA,WAAA,CAAA,QAAA,GAAA,UAAA,GAAA,EAAA,SAAA,EAAA;QACI,KAAJ,qBAAA,CAAA,GAAA,GAAA,CAAA,MAAA,GAAA,CAAA,EAAA,CAAA,IAAA,CAAA,EAAA,CAAA,EAAA,EAAA;YACA,IAAA,SAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,EAAA;;;;;;;;;;;;IAYA,WAAA,CAAA,SAAA,GAAA,UAAA,IAAA,EAAA,KAAA,EAAA;QACA,KAAA,qBAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,CAAA,MAAA,EAAA,EAAA,CAAA,EAAA;YACA,qBAAA,KAAA,GAAA,IAAA,CAAA,OAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,CAAA;;;;;;;;;;;;IAYA,WAAA,CAAA,MAAA,GAAA,UAAA,IAAA,EAAA,EAAA,EAAA;QACI,qBAAJ,KAAA,GAAA,IAAA,CAAA,OAAA,CAAA,EAAA,CAAA,CAAA;QACA,IAAA,KAAA,GAAA,CAAA,CAAA,EAAA;;;;;;;;;;;IArBA,WAAA,CAAA,MAAA,GAAA,UAAA,CAAA,EAAA,CAAA,EAAA;QA+BA,IAAA,CAAA,CAAA,MAAA,IAAA,CAAA,CAAA,MAAA;YACA,OA9BW,KA8BX,CAAA;QACA,KAAA,qBAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,CAAA,CAAA,MAAA,EAAA,EAAA,CAAA,EAAA;;;;;;;;;;;IAWA,WAAA,CAAA,OAAA,GAAA,UAAA,IAAA,EAAA;;;;;;;;;;;;IAYA,WAAA,CAAA,OAAA,GAAA,UAAA,IAAA,EAAA,QAAA,EAAA;;YD/HA,QAAA,CAAA,IAAyB,CAAzB,QAAA,EACE,IADF,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA;SAEA;KACA,CAAA;;;AAGA,IAAA,gBAAA,GAAA,IAAA,MAAA,CAAA,cAAA;IACE,YAAF;IACM,mBAAN;;;;;;;;;;;AAUA,IAAA,WAAA,IAAA,YAAA;IAkHA,SAAA,WAAA,GAAA;;;;;KA7GA;;;;;IAKA,WAAA,CAAA,WAAA,GAAA,UAAA,OAAA,EAAA;QACA,qBAAA,QAAA,GAAA,IAAA,WAAA,EAAA,CAAA;QACA,QAAA,CAAA,UAAA,CAAA,OAAA,CAAA,OAAA,CAAA,iBAAA,EAAA,CAAA,CAAA;QACI,WAAW,CAFC,OAAC,CAAO,OAAC,CAAO,UAEhC,EAF2C,UAAI,IAE/C,EAAA;YACA,IAAA,IAAA,CAAA,IAAA,CAAA,iBAAA,EAAA,KAAA,OAAA,EAAA;gBACA,QAAA,CAAA,YAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA,EAAA,EAAA,IAAA,CAAA,KAAA,CAAA,IAAA,EAAA,CAAA,CAAA;;;;;KAKA,CAAA;;;;;IAKA,WAAA,CAAA,KAAQ,GAAR,UAAA,QAAA,EAAA;QACA,qBAAA,OAAA,GAAA,EAAA,CAAA;QACA,qBAAA,UAAA,GAAA,UAAA,GAAA,EAAA,MAAA,EAAA;YACA,IAAA,MAAA,CAAA,YAAA,CAAA,MAAA,GAAA,CAAA,IAAA,CAAA,MAAA,CAAA,OAAA,IAAA,MAAA,CAAA,UAAA,CAAA,MAAA,IAAA,CAAA;gBACA,MAAA,CAAA,KAAA,CALQ,MAKR,IAAA,CALQ,EAKR;gBACA,MAAA,CAAA,OAAA,GAAA,GAAA,CAAA;aACA;YACA,GAAA,CAAA,IAAA,CAAA,MAAA,CAAA,CALQ;SAMR,CAAA;QACI,qBAAJ,WALoC,GAKpC,IAAA,WAAA,EAAA,CAAA;QACA,qBAAA,KAAA,CAAA;QACA,qBAAA,OAAA,GAAA,WAAA,CAAA;QACA,qBAAA,KAAA,GAAA,KAAA,CAAA;QACA,gBAAA,CAAA,SAAA,GAAA,CAAA,CAAA;QACA,OAAA,KAAA,GAAA,gBAAA,CAAA,IAAA,CAAA,QAAA,CAAA,EAAA;YACA,IAAQ,KAAR,CAAA,CAAe,CAAf,EALkB;gBAMV,IAAR,KAAA,EAAmB;oBACnB,MAAA,IAAA,KAAA,CAAA,2CAAA,CAAA,CAAA;iBACA;gBACQ,KAAR,GALgB,IAKhB,CAAA;gBACA,OAAA,GAAA,IAAA,WAAA,EAAA,CAAA;gBACU,WAAV,CAAA,YAAA,CAAA,IAAA,CAAA,OAAA,CAAA,CAAA;aACA;YACA,IAAA,KAAA,CAAA,CAAA,CAAA,EAAA;gBACU,OALO,CAAC,UAKlB,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,CAAA;aACA;YACA,IAAA,KAAA,CAAA,CAAA,CAAA,EAAA;gBACU,OALO,CAAC,YAKlB,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,CAAA;aACA;YACA,IAAQ,KAAR,CAAA,CAAe,CAAf,EALkB;gBAMlB,OAAA,CAAA,YAAA,CAAA,KAAA,CAAA,CAAA,CAAA,EAAA,KAAA,CAAA,CAAA,CAAA,CAAA,CAAA;aACA;YACA,IAAQ,KAAR,CAAA,CAAA,CAAA,EAAA;gBACA,KAAA,GAAA,KAAA,CALoB;gBAMpB,OAAA,GAAA,WAAA,CAAA;aACA;YACA,IAAQ,KAAR,CAAA,CAAA,CAAA,EAAA;gBACA,IAAA,KAAA,EAAA;oBACA,MAAA,IAAA,KAAA,CAAA,8CAAA,CAAA,CAAA;iBACA;gBACA,UAAA,CAAA,OAAA,EAAA,WAAA,CAAA,CAAA;gBACA,WAAA,GAAA,OAAA,GAAA,IAAA,WAAA,EAAA,CAAA;;;;QAIA,OAAA,OAAA,CAAA;KACA,CAAA;;;;;;YAMA,IAAA,CAAA,YAAA,CAAA,MAT2C,KAAK,CAShD,CAAA;;;;;IAKA,WAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,YAAA,EAAA,OAAA,CAAA,CAAA,IAAA,CAAA,OAZsD,CAYtD,EAAA,CAAA;;;;;;;;;;;;;;;;;KAaA,CAAA;;;;;IAKA,WAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAA,IAAA,EAAA,EAAA,IApBQ,CAoBR,UApB2B,CAoB3B,IAAA,CAAA,IAAA,CApBsC,WAoBtC,EAAA,CAAA,CAAA,EAAA,CAAA;;;;IAIA,WAAA,CAAA,SAAA,CAAA,QAAQ,GAAR,YAAA;QACA,qBAAA,GAAA,GAAA,IApBe,CAoBf,OAAA,IAAA,EApB0B,CAAK;QAqB/B,IAAA,IAAQ,CAAR,UAAA,EAAA;YACA,IAAQ,CAAR,UAAA,CAAA,OAAA,CAAA,UAAA,KAAA,EAAA,EAAA,OAAA,GAAA,IApB2B,GAoB3B,GAAA,KApBqC,CAoBrC,EApBqC,CAAE,CAAC;SAqBxC;QACA,IAAA,IAAA,CAAA,KAAA,EAAA;YACA,KAAA,qBAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,MAAA,EAAA,CAAA,IAAA,CAAA,EAAA;gBACA,qBAAA,IAAA,GAAA,IAAA,CAAA,KApBoD,CAoBpD,CAAA,CAAA,CAAA;gBACA,qBAAA,KAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA;gBACA,GAAA,IAAA,GAAA,GAAA,IAAA,IAAA,KAAA,GAAA,GAAA,GAAA,KAAA,GAAA,EAAA,CAAA,GAAA,GAAA,CAAA;aACA;SAEA;;;;IAeA,OAAA,WAAA,CAAA;CAAA,EAAA,CAAA,CAAA;;;;;AArBA,IAAA,eAAA,IAAA,YAAA;IACA,SAAA,eAAA,GAAA;QACU,IAAV,CAAA,WAAA,GAAA,IAAA,GAAA,EAAiC,CAAjC;QACU,IAAV,CAAA,kBAAiD,GAAjD,IAAA,GAAA,EAAA,CAAA;QA0PA,IAAA,CAAA,SAAA,GAAA,IAAA,GAAA,EAAA,CAAA;;;;;KAnOA;;;;;;;;;;;;;;;IAsBA,eAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAA,YAAA,EAAA,YAAA,EAAA;QACI,qBAAJ,WAAA,GAAA,IAAA,CAAA;QACA,IAAM,YAAN,CAAA,MAtCY,GAsCZ,CAAA,EAAA;YACA,WAAA,GAAA,IAAA,mBAAA,CAAA,YAAA,CAAA,CAAA;YACA,IAAA,CAAA,aAAA,CAAA,IAAA,CAAA,WAAA,CAAA,CAAA;;;;;;;;;;;;;IAcA,eAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAA,WAAA,EAAA,YAvCuB,EAuCvB,WAAA,EAAA;QAEI,qBAAJ,OAAA,GAAA,IAAA,CAAA;QACA,qBAAA,OAAA,GAAA,WAAA,CAvCyB,OAAO,CAuChC;QACA,qBAAA,UAAA,GAAA,WAAA,CAAA,UAAA,CAAA;QACA,qBAAA,KAAA,GAAA,WAAA,CAAA,KAAA,CAAA;QACA,qBAAA,UAAA,GAAA,IAAA,eAAA,CAAA,WAAA,EAAA,YAAA,EAAA,WAAA,CAAA,CAAA;QAvCA,IAAA,OAAA,EAAA;YAwCA,qBAAA,UAAA,GAAA,KAAA,CAAA,MAAA,KAAA,CAAA,IAAA,UAvCwE,CAuCxE,MAAA,KAAA,CAAA,CAAA;YACA,IAAA,UAAA,EAAA;gBACA,IAAA,CAAA,YAAA,CAAA,OAAA,CAAA,WAAA,EAAA,OAAA,EAAA,UAAA,CAAA,CAAA;aAEA;iBACW;gBACH,OAAR,GAAA,IAAA,CAAA,WAAA,CAAA,OAAA,CAAA,kBAvC4C,EAuC5C,OAAA,CAAA,CAvCuD;aAwCvD;SACA;QACA,IAAA,UAAA,EAAc;YACd,KAAS,qBAAT,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,UAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA;gBAvCA,qBAAA,UAAA,GAAA,KAAA,CAAA,MAAA,KAAA,CAAA,IAAA,CAAA,KAAA,UAAA,CAAA,MAAA,GAAA,CAAA,CAAA;gBAwCA,qBAAA,SAAA,GAAA,UAAA,CAAA,CAAA,CAAA,CAAA;gBACA,IAAA,UAAA,EAAA;oBACA,IAAA,CAAA,YAAA,CAAA,OAAA,CAAA,SAAA,EAAA,SAAA,EAAA,UAAA,CAAA,CAAA;iBACA;qBAEA;oBACA,OAAA,GAAA,IAAA,CAAA,WAvCsB,CAuCtB,OAvC0B,CAAM,gBAAgB,EAuChD,SAAA,CAAA,CAAA;iBACA;aACA;SACA;QACA,IAAA,KAAA,EAAA;YACA,KAAA,qBAAA,CAAA,GAAA,CAvCgB,EAuChB,CAAA,GAAA,KAvCgB,CAuChB,MAAA,EAAA,CAvC8B,IAuC9B,CAAA,EAAA;gBACA,qBAAA,UAAA,GAAA,CAAA,KAvCc,KAuCd,CAAA,MAAA,GAvC8C,CAuC9C,CAAA;gBACA,qBAAA,IAAA,GAAA,KAAA,CAAA,CAAA,CAAA,CAAA;gBACA,qBAAA,KAvCgC,GAuChC,KAAA,CAvCkE,CAAG,GAuCrE,CAAA,CAAA,CAAA;gBACA,IAAA,UAAA,EAAA;oBACA,qBAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;oBACU,qBAAV,iBAAA,GAAA,WAAA,CAAA,GAvCkE,CAuClE,IAAA,CAAA,CAAA;oBACA,IAAA,CAAA,iBAAA,EAAA;wBAvCA,iBAAA,GAAA,IAAA,GAAA,EAAA,CAAA;wBAwCA,WAAA,CAAA,GAAA,CAAA,IAAA,EAAA,iBAvC6B,CAAQ,CAuCrC;qBACA;oBACU,IAAI,CAvCC,YAuCf,CAAA,iBAAA,EAAA,KAAA,EAAA,UAAA,CAAA,CAAA;iBACA;qBACA;oBACA,qBAAA,UAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;oBACU,qBAAV,gBAAA,GAAA,UAvCuD,CAAM,GAuC7D,CAAA,IAAA,CAAA,CAAA;oBACA,IAAA,CAAA,gBAAA,EAAA;wBACA,gBAAA,GAAA,IAAA,GAAA,EAAA,CAAA;wBACA,UAAA,CAAA,GAAA,CAAA,IAAA,EAAA,gBAAA,CAAA,CAAA;qBACA;;;;;;;;;;;;IAaA,eAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAA,GAAA,EAAA,IAAA,EAAA,UAAA,EAAA;QACI,qBAAJ,YAAA,GAAA,GAAA,CAAA,GAAA,CAAA,IAAA,CAAA,CAAA;QACA,IAAA,CAAA,YAAA,EAAA;;;;;;;;;;;IAWA,eAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAA,GAAA,EAAA,IAAA,EAAA;QACI,qBAAJ,OAAA,GAAA,GAAA,CAAA,GAAA,CAAA,IAAA,CAAA,CAAA;QACA,IAAA,CAAA,OAAA,EAAA;;;;;;;;;;;;;IAeA,eAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAA,WAAA,EAAA,eAAA,EAAA;QAAA,IAAA,eAAA,KAAA,KAAA,CAAA,EAAA,EAAA,eAAA,GAAA,YAAA,GAAA,CAAA,EAAA;QACA,qBAAA,MAAA,GAAA,KAAA,CAAA;QACA,qBAAA,OAAA,GAAA,WAAA,CAAA,OAAA,CAAA;QAEI,qBAAJ,UA/CkC,GA+ClC,WA/CmD,CA+CnD,UAAA,CAAA;QACI,qBAAJ,KA/CgC,GA+ChC,WAAA,CAAA,KAAA,CAAA;QACA,KAAA,qBAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,IAAA,CAAA,aAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA;YAEQ,IAAR,CAAA,aAAA,CAAA,CAAA,CAAA,CAAA,cAAA,GAAA,KAAA,CAAA;SACA;QACA,MAAA,GAAA,IAAA,CAAA,cAAA,CAAA,IAAA,CAAA,WAAA,EAAA,OA/CqC,EAAE,WA+CvC,EAAA,eAAA,CAAA,IAAA,MAAA,CAAA;QACA,MAAA,GAAA,IAAA,CAAc,aAAd,CAAA,IAAA,CAAA,kBAAA,EAAA,OAAA,EAAA,WAAA,EAAA,eAAA,CAAA;YACA,MAAA,CAAA;QACA,IAAA,UAAc,EAAd;YACA,KAAA,qBA/CgB,CAAa,GA+C7B,CA/C8B,EA+C9B,CAAA,GAAA,UAAA,CA/CmC,MA+CnC,EAAA,CAAA,EA/CoD,EAAW;gBAgD/D,qBAAA,SAAA,GAAA,UAAA,CAAA,CAAA,CAAA,CAAA;gBACA,MAAA;oBACA,IAAA,CAAA,cAAA,CAAA,IAAA,CAAA,SAAA,EAAA,SAAA,EAAA,WAAA,EAAA,eAAA,CAAA,IAAA,MAAA,CAAA;gBAEA,MAAA;oBACA,IAAA,CAAA,aA/Ce,CAAA,IAAI,CA+CnB,gBAAA,EAAA,SA/CgD,EA+ChD,WAAA,EAAA,eAAA,CAAA;wBACA,MAAA,CAAA;aACA;SAEA;QACA,IAAA,KAAA,EAAA;YACA,KAAA,qBAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,CAAA,MAAA,EAAA,CAAA,IAAA,CAAA,EAAA;gBACA,qBAAA,IA/CkB,GA+ClB,KAAA,CAAA,CAAA,CAAA,CAAA;gBACA,qBAAA,KAAA,GAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA;gBACQ,qBAAR,iBAAA,GAAA,IAAA,CAAA,aAAA,CAAA,GAAA,CAAA,IAAA,CAAA,CAAA;gBACA,IAAU,KA/CK,EA+Cf;oBAEA,MAAA;wBACA,IAAA,CAAA,cAAA,CAAA,iBAAA,EAAA,EAAA,EAAA,WAAA,EAAA,eAAA,CAAA,IAAA,MAAA,CAAA;iBACA;gBACA,MAAA;oBACA,IAAA,CAAA,cAAA,CAAA,iBAAA,EAAA,KAAA,EAAA,WAAA,EAAA,eAAA,CAAA,IAAA,MAAA,CAAA;gBACA,qBA/C6B,gBAAC,GA+C9B,IA/C+C,CA+C/C,oBAAA,CAAA,GAAA,CAAA,IA/CmE,CAAgB,CA+CnF;gBACA,IAAA,KAAA,EAAA;oBACA,MAAA,GAAA,IAAA,CAAA,aAAA,CAAA,gBAAA,EAAA,EAAA,EAAA,WAAA,EAAA,eAAA,CAAA,IAAA,MAAA,CAAA;iBACA;gBACA,MAAA;;;;;;;;;;;;;;IAiBA,eAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAA,GAAA,EAAA,IAAA,EAAA,WAAA,EAAA,eAAA,EAAA;QACI,IAAI,CAAR,GAAA,IAAA,OArDS,IAqDT,KAAA,QAAA,EAAA;YACM,OAAN,KAAA,CAAA;SACK;QACD,qBAAJ,WAAA,GAAA,GAAA,CAAA,GAAA,CAAA,IAAA,CAAA,IAAA,EAAA,CAAA;QACA,qBAAA,eAAA,GAAA,GAAA,CAAA,GAAA,CAAA,GAAA,CAAA,CAAA;QACA,IAAA,eAAA,EAAA;YACA,WAAA,GAAA,WAAA,CAAA,MAAA,CAAA,eAAA,CAAA,CAAA;SACA;QACI,IAAJ,WAAA,CAAA,MAAA,KArDa,CAqDb,EArDiB;YAsDX,OAAN,KAAA,CArDmB;SAsDnB;QACA,qBAAA,UAAA,CAAA;QACI,qBAAJ,MAAA,GAAA,KAAA,CAAA;QACA,KAAA,qBAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,WAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA;;;;;;;;;;;;;;IAiBA,eAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAA,GAAA,EAAA,IA3DU,EAAe,WA2DzB,EAAA,eAAA,EAAA;QACA,IAAM,CAAN,GAAA,IAAA,OAAA,IAAA,KAAA,QAAA,EAAA;YACA,OAAA,KAAA,CAAA;;;;YAIA,OAAA,KAAA,CAAA;SACA;;;;;;IAyBA,OAAA,eAAA,CAAA;CAAA,EAAA,CAAA,CAAA;AA7EA,IAAA,mBAAA,IAAA,YAAA;;;;IAgFA,SAAA,mBAAA,CAAA,SAAA,EAAA;;;;;CAhFA,EAAA,CAAA,CAAA;;;;;;;IAmGA,SAAA,eAAA,CAAA,QAAA,EAAA,SAAA,EAAA,WAAA,EAAA;;;;;;;;;;;IAWA,eAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAA,WAAA,EAAA,QAAA,EAAA;QACI,qBAAJ,MA5F8B,GA4F9B,IAAA,CAAA;QACA,IAAM,IAAI,CAAV,YAAA,CAAA,MAAA,GAAA,CAAA,KAAA,CAAA,IAAA,CAAA,WAAA,IAAA,CAAA,IAAA,CAAA,WAAA,CAAA,cAAA,CAAA,EAAA;YACA,qBAAA,UAAA,GAAA,eAAA,CAAA,gBAAA,CAAA,IAAA,CAAA,YAAA,CAAA,CAAA;YACA,MAAA,GAAA,CAAA,UAAA,CAAA,KAAA,CAAA,WAAA,EAAA,IAAA,CAAA,CAAA;SACA;QACA,IAAA,MAAA,IAAA,QAAA,KAAA,CAAA,IAAA,CAAA,WAAA,IAAA,CAAA,IAAA,CAAA,WAAA,CAAA,cAAA,CAAA,EAAA;YACA,IAAA,IAAA,CA5FW,WA4FX,EAAA;gBACA,IAAA,CAAA,WAAA,CAAA,cAAA,GAAA,IAAA,CAAA;aACA;;SDhcA;;;;;;;;;AAgBA,IAAA,SAAA,IAAA,UAAA,MAAA,EAAA;IAAA,SAAA,CAAA,SAAA,EAAA,MAAA,CAAA,CAAA;;;;IAIA,SAAA,SAAA,CAAA,OAAA,EAAA;QAAA,IAAA,KAAA,GACA,MADA,CAAA,IAAA,CAAA,IAAA,EACA,OAAA,CAAA,IADA,IAAA,CAAA;;;;QAMG,KADH,CAAA,YAAA,GAAA,WAAA,CAAA;;;IAKA,MAAA,CAAA,cAAA,CAHG,SAGH,CAAA,SAAA,EAAA,SAHG,EAGH;;;;QAAA,GAAA,EAAA,YAAA,EAAA,OAHyB,IAAA,CAAK,YAAC,CAAY,OAAC,CAG5C,EAHqD;;;;;;;;KAArD,CAAA,CAAqD;;;;;;;;;IAgBrD,MAAA,CAAA,cAAA,CAbG,SAaH,CAAA,SAAA,EAAA,OAbG,EAaH;;;;QAAA,GAAA,EAAA,YAAA,EAAA,OAbqB,EAarB,IAAA,CAAA,YAAA,GAAA,KAAA,CAbwD,EAaxD;;;;;QAKA,GAAA,EAAA,UAAA,KAAA,EAAA,EAAA,EAAA,IAAA,CAAA,YAAA,GAAA,KAAA,GAAA,KAAA,CAAA,EAAA;;;KALA,CAAA,CAAA;;;;;;CA3BA,CAAA,KAAA,CAAA,CAAA,CAAA;AAgDA,IAAA,YAAA,IAAA,UAAA,MAAA,EAAA;IAAA,SAAA,CAAA,YAAA,EAAA,MAAA,CAAA,CAAA;;;;;;QAQA,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA,GAAA,cAAA,IAAA,KAAA,YAAA,KAAA,GAAA,KAAA,CAAA,OAAA,GAAA,KAAA,CAAA,CAAA,IAAA,IAAA,CAAA;QA9BG,KA6BH,CA7BG,aA6BH,GAAA,KAAA,CAAA;;KACA;;;;;;YDxEA,OAAA,GAAA,IAAA,CAAA,aAAA,YAAA,KAAA,GAAA,IAAA,CAAA,aAAA,GAAA,IAAA,CAAA,YAAA;;;;;;;CCgEA,CAAA,SAAA,CAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;ADvCA,SAAA,SAAA,CAAA,KAAA,EAAA;IACA,IAAA,OAAA,KAAA,KAAA,QAAA,EAAA;QACM,OAAN,KAAkB,CAAlB;KACA;IACA,IAAA,KAAA,KAAA,SAAA,IAAA,KAAA,KAAA,IAAA,EAAA;QACM,OAAN,EAAA,GAAA,KAAA,CAAA;KACA;IACA,IAAA,KAAA,CAAA,IAAA,EAAA;QACM,OAAO,KAAA,CAAb,IAAuB,CAAvB;KACA;IACA,IAAA,KAAA,CAAA,cAAA,EAAA;QACM,OAAN,KAAA,CAAA,cAAA,CAAuB;KACvB;IACA,IAAI,OAAJ,KAAA,KAAA,UAA+B,EAA/B;QACA,OAAA,YAAA,CAAA,KAAA,CAAA,CAAA;KACA;IACA,IAAA,KAAA,YAAA,WAAA,EAAA;QAEA,qBAAA,KAAA,GAAkB,KAAlB,CAAA,QAAA,EAAA,CAAA,KAAA,CAAA,MAAA,CAAA,CAAA;QACA,IAAA,KAAA,IAAA,KAAA,CAAA,MAAA,EAAA;YACS,OAAT,KAAW,CAAX,KAA2B,CAAE,MAA7B,GAAA,CAAuC,CAAvC,CAAA;SACA;KAsBA;IACI,qBAAJ,GAAA,GAAA,KAAA,CAAA,QAAA,EAAA,CAAA;IACE,qBAAF,YAAmC,GAAnC,GAAA,CAAA,OAAA,CAAkD,IAAA,CAAlD,CAAA;;CAEA;AACA,IAAA,WAAA,CAAA;AAAA,IAAA,OAAA,MAAA,KAAA,WAAA,EAAA;IACA,IAAI,OAAJ,iBAAA,KAAA,WAAA,IAAA,IAAA,YAAA,iBAAA,EAAA;;QAEA,WAAA,IAAA,IAAA,CAAA,CAAA;KAAO;SACP;QACA,WAAA,IAAA,MAAA,CAAA,CAAA;KACA;;;;CAKA;;;;;;;CAOA;;;;;AAQA,IAAA,aAAA,IAAA,YAAA;IAAA,SAAA,aAAA,GAAA;;;;;;IAKA,aAAA,CAAA,iBAAA,GAAA,UAAA,IAAA,EAAA;QACA,qBAAA,MAAA,GAAA,QAAA,CAAA,IAAA,CAAA,CAAA;;;;;KAKA,CAAA;;;;;;;CAXA,EAAA,CAAA,CAAA;AD3FA,IAAA,UAAA,IAAA,YAAA;;;;IAMA,SAAA,UAAA,CAAU,UAAV,EAAA;QAAA,IAAA,KAAA,GAAA,IAAA,CAAA;QACA,IAAM,CAAN,gBAAA,GAAA,IAAA,eAAA,EAAA,CAAgD;QAChD,IAAA,CAAA,gBAAA,GAAA,IAAA,GAAA,EAAA,CAAA;QACA,UAAA,CAAA,OAAA,CAAA,UAAA,SAAA,EAAA,KAAA,EAAA;;;;;;;;;;;IAWA,UAAA,CAAA,SAAA,CAAA,YAAQ,GAAR,UAAA,OAAA,EAJkB,OAIlB,EAAA;QACA,qBAAA,kBAAA,GAAA,WAAA,CAAA,WAAA,CAAA,OAAA,CAAA,CAAA;QACA,qBAAuB,iBAAvB,CAAA;QACA,IAAA,CAAA,gBAAA,CAAA,KAAA,CAAA,kBAAA,EAAA,UAAA,QAAA,EAAA,SAAA,EAAA;;gBAGA,MAAA,IAAA,gCAAA,CAAA,CAAA,iBAAA,CAAA,IAAA,EAAA,SAAA,CAAA,IAAA,CAAA,CAAA,CAAA;aACA;YACA,iBAAA,GAAA,SAAA,CAAA;;;QAKI,IAAJ,CAAA,iBAAA,EAAA;;;;QAOA,qBAAA,OAAA,GAAA,iBAAA,CAAA,qBAAA,EAAA,CAAA;QAEI,qBAAJ,IAAA,GAAAgC,sBAAA,CAAA,OAAA,CAAA,IAAA,EAAA,OAAA,EAAA,OAAA,EAAA,OAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;IAmCA,OAAA,UAAA,CAAA;CAAA,EAAA,CAAA,CAAA;AACA,IAAA,UAAA,IAAA,UAAA,MAAA,EAAA;IAAA,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA,CAAA;;;;;;;IAOA,OAAA,UAAA,CAAA;CAAA,CAPA,YAAA,CAOA,CAAA,CAAA;AACA,IAAA,gCAAA,IAAA,UAAA,MAAA,EAAA;IAAA,SAAA,CAAA,gCAAA,EAAA,MAAA,CAAA,CAAA;;;;IAIA,SAAA,gCAAA,CAAA,UAAA,EAAA;QAAA,IAAA,KAAA,GAAA,IAAA,CAAA;;QDlGA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAA,kCAAA,GAAA,KAAA,GAAA,sCAAA;;;;;CC8FA,CAAA,UAAA,CAAA,CAAA,CAAA;;;;;;;;ADlFA,IAAa,IAAb,GAAA,CAAmB,CAAG;AACtB,IAAa,IAAb,GAAA,CAAA,CAAsB;AACtB,IAAa,GAAb,GAAA,EAAqB,CAArB;AACA,IAAa,KAAb,GAAmB,EAAnB,CAAA;AACA,IAAa,GAAb,GAAA,EAAqB,CAArB;AACA,IAAa,GAAb,GAAA,EAAqB,CAArB;AACA,IAAa,MAAb,GAAA,EAAwB,CAAxB;AACA,IAAa,KAAb,GAAA,EAAa,CAAb;AACA,IAAa,GAAA,GAAM,EAAA,CAAG;AACtB,IAAa,KAAb,GAAA,EAAuB,CAAvB;AACA,IAAa,EAAb,GAAA,EAAa,CAAb;AACA,IAAa,QAAQ,GAAG,EAAxB,CAAA;AACA,IAAa,UAAQ,GAArB,EAAA,CAAA;AACA,IAAa,GAAb,GAAa,EAAb,CAAsB;AACtB,IAAa,OAAb,GAAA,EAAyB,CAAzB;AACA,IAAa,OAAA,GAAU,EAAA,CAAG;AAC1B,IAAa,KAAb,GAAA,EAAA,CAAsB;AACtB,IAAa,KAAb,GAAA,EAAA,CAAsB;AACtB,IAAa,MAAb,GAAA,EAAA,CAAA;AACA,IAAa,MAAM,GAAG,EAAtB,CAAA;AACA,IAAa,OAAb,GAAA,EAAA,CAAA;AACA,IAAa,MAAM,GAAG,EAAtB,CAAA;AACA,IAAa,MAAb,GAAa,EAAb,CAAyB;AAEzB,IAAa,UAAb,GAAA,EAAA,CAAA;AACA,IAAa,GAAb,GAAA,EAAqB,CAArB;AAEA,IAAa,GAAb,GAAA,EAAqB,CAArB;AACA,IAAa,GAAb,GAAA,EAAqB,CAArB;AACA,IAAA,SAAA,GAAA,EAAA,CAAA;AACA,IAAA,EAAA,GAAA,EAAA,CAAA;AACA,IAAa,EAAA,GAAK,EAAA,CAAG;AAErB,IAAa,EAAb,GAAA,EAAA,CAAA;AACA,IAAa,EAAb,GAAA,EAAA,CAAA;AAGA,IAAa,EAAA,GAAK,EAAA,CAAG;AAErB,IAAa,SAAb,GAAA,EAAA,CAAA;AACA,IAAa,UAAb,GAAA,EAAA,CAAA;AACA,IAAa,SAAS,GAAtB,EAAA,CAAA;AACA,IAAa,MAAb,GAAsB,EAAtB,CAAA;AACA,IAAa,EAAA,GAAK,EAAlB,CAAkB;AAClB,IAAa,EAAA,GAAK,EAAlB,CAAkB;AAClB,IAAa,EAAA,GAAK,GAAA,CAAI;AACtB,IAAa,EAAA,GAAK,GAAA,CAAI;AACtB,IAAA,EAAA,GAAA,GAAA,CAAA;AACA,IAAa,EAAA,GAAK,GAAA,CAAI;AAEtB,IAAa,EAAb,GAAA,GAAA,CAAA;AACA,IAAa,EAAb,GAAA,GAAA,CAAA;AACA,IAAa,EAAb,GAAA,GAAA,CAAA;AAGA,IAAA,EAAA,GAAA,GAAA,CAAA;AACA,IAAA,OAAA,GAAA,GAAA,CAAA;AACA,IAAA,IAAA,GAAA,GAAA,CAAA;AAEA,IAAA,OAAA,GAAA,GAAA,CAAA;;;;;;;;CAYA;;;;;;;CAOA;;;;;;IAMA,OAAA,IAAA,IAAA,EAAA,IAAA,IAAA,IAAA,EAAA,IAAA,IAAA,IAAA,EAAA,IAAA,IAAA,IAAA,EAAA,CAAA;;;;;;;;;;;;;AD9EA,IAAA,SAAA,GAAA,EAAU,CAAV;AACA,SAAQ,CAAA,SAAA,GAAR,CAAA,CAAA;AACA,SAAE,CAAA,UAAA,GAAF,CAAA,CAAA;AACA,SAAS,CAAC,OAAV,GAAoB,CAApB,CAAA;AACA,SAAM,CAAA,MAAN,GAAmB,CAAA,CAAnB;AACA,SAAS,CAAC,QAAV,GAAA,CAAA,CAAA;AACA,SAAS,CAAC,MAAV,GAAmB,CAAC,CAApB;AACA,SAAS,CAAC,KAAV,GAAA,CAAmB,CAAC;AACpB,SAAS,CAAC,SAAS,CAAC,SAApB,CAA8B,GAA9B,WAAA,CAAA;AACA,SAAS,CAAC,SAAS,CAAC,UAApB,CAAA,GAAA,YAAA,CAAA;AAGA,SAAA,CAAA,SAAA,CAAA,OAAA,CAAA,GAAA,SARwC,CAQxC;AACA,SAAA,CAAA,SAAA,CAAA,MAAA,CAAA,GAAA,QAAA,CAAA;;;;;AAKA,IAAA,mBAAA,IAAA,YAAA;IAAA,SAAA,mBAAA,GAAA;;;;;;IAKA,mBAAA,CAAA,SAAA,CAAA,QAAM,GAAN,UAAA,IAAA,EAAA;QACA,qBAAA,OAAA,GAAA,IAAA,OAAA,CAAA,IAAA,CAAA,CAAA;QACA,qBAAA,MAAA,GAAA,EAAA,CAAA;QACI,qBAAJ,KAAA,GAAA,OAAA,CAAA,SAAA,EAAA,CAAA;QACA,OAAA,KAAA,IAAA,IAAA,EAAA;;;;;KAKA,CAAA;;;;;IAIA,mBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAbE,IAaF,EAAA;QACA,OAAA,IAAA,UAAA,CAAA,IAAA,CAAA,QAAA,CAAA,IAAA,CAAA,CAAA,CAAA;;;CAnBA,EAAA,CAAA,CAAA;;IAQA9B,EAAAA,IAAAA,EAAAA,sBAAAA,EAAAA;CAmBA,CAAA;;;;;;;;;;;;IAZA,SAAA,QAAA,CAAA,KAAA,EAAA,IAAA,EAAA,QAAA,EAAA,QAAA,EAAA;;;;;KAsCA;;;;;;QAMA,OAAA,IAAA,CAAA,IAtC+B,IAAA,SAAa,CAsC5C,SAtCsD,IAsCtD,IAAA,CAtC8D,QAsC9D,IAAA,IAAA,CAAA;;;;;;;;;IASA,QAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA,EAAA,OAAA,IAAA,CAAA,IAAA,IAAA,SAAA,CAAA,MAAA,CAAA,EAAA,CAAA;;;;;;QAMA,OAAA,IAAA,CAAA,IAAA,IA7CmC,SAAM,CA6CzC,QAAA,IA7CgD,IA6ChD,CAAA,QAAA,IAAA,QAAA,CAAA;;;;;;;;;;;;;;;;;IAiBA,QAAA,CAAA,SAAA,CAAA,aAAA,GAAA,YAAA,EAAA,OAAA,IAAA,CAAA,IArDkC,IAqDlC,SAAA,CAAA,OAAA,IAAA,IAAA,CAAA,QAAA,IAAA,MAAA,CAAA,EAAA,CAAA;;;;;QAKA,OAAA,IAAA,CAAA,IAAA,IAAA,SAAA,CAvD0C,OAuD1C,IAAA,IAAA,CAAA,QAAA,IAAA,WAAA,CAAA;;;;;;;;;;;;;;;;;;;;;IAqBA,QAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA,EAAA,OAAA,IAAA,CAAA,IAAA,IAAA,SAAA,CAAA,MAAA,GAAA,IAAA,CAAA,QAAA,GAAA,CAAA,CAAA,CAAA,EAAA,CAAA;;;;IAIA,QAAA,CAAA,SAAA,CAAA,QAAM,GAAN,YAAA;QACA,QAAA,IAAA,CAAA,IAAA;YACM,KAjEK,SAAA,CAAU,SAiErB,CAAA;YACA,KAAA,SAAA,CAjEe,UAAc,CAiE7B;YACM,KAjEK,SAAA,CAAU,OAiErB,CAAA;YACA,KAAA,SAAA,CAjEe,QAiEf,CAjEqB;YAkEf,KAAN,SAAA,CAAA,MAAA,CAAA;YACA,KAAA,SAAA,CAjEe,KAiEf;gBACA,OAAA,IAAA,CAAA,QAAA,CAAA;YACA,KAAA,SAAA,CAAA,MAAA;gBACA,OAAA,IAAA,CAAA,QAAA,CAAA,QAAA,EAAA,CAAA;YAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4EA,IAAA,GAAA,GAAA,IA1GqB,QA0GrB,CAAA,CAAA,CAAA,EAAA,SAAA,CAAA,SAAA,EAAA,CAAA,EAAA,EAAA,CAAA,CAAA;AA1GA,IAAA,OAAA,IAAA,YAAA;;;;IA4GA,SAAA,OAAA,CAAA,KAAA,EAAA;QACA,IAAA,CAAA,KAAA,GAAA,KAAA,CAAA;;;;QAIA,IAAA,CAAA,OAAA,EAAA,CAAA;KACA;;;;;QAKA,IAAA,CA9GG,IA8GH,GAAA,EAAA,IAAA,CAAA,KAAA,IAAA,IAAA,CAAA,MAAA,GAAA,IAAA,GAAA,IAAA,CAAA,KAAA,CAAA,UAAA,CAAA,IAAA,CAAA,KAAA,CAAA,CAAA;KACA,CAAA;;;;IAKA,OAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;QACA,qBAAA,KAAA,GAAA,IAAA,CAAA,KAAA,mBAAA,MAAA,GAAA,IAAA,CAAA,MAAA,CAAA;QACA,qBAAA,IAAA,GAAA,IAAA,CAAA,IAAA,mBAAA,KAAA,GAAA,IAAA,CAAA,KAAA,CAAA;;QA7GA,OAAA,IAAA,IAAA,MAAA,EAAA;YA+GA,IAAQ,EAAR,KA9Ge,IA8Gf,MAAA,EAAA;gBACA,IAAA,GAAA,IAAA,CAAA;gBACA,MAAA;aA5GS;iBA+GT;gBAEA,IAAA,GAAA,KAAA,CA9GyB,UA8GzB,CAAA,KAAA,CAAA,CAAA;aACA;SACK;;QAGD,IAAI,CAAR,KAAA,GAAA,KAAA,CAAA;QA9GA,IAAiC,KAAjC,IAAA,MAAA,EAAA;YA+GQ6B,OA9GO,IA8Gf,CA9GuB;SAAvB;;QAiHI,IAAJ,iBAAA,CAAA,IAAA,CAAA;YACM,OAAN,IAAA,CA9GkB,cA8GlB,EAAA,CAAA;QACA,IAAA,OAAA,CAAY,IAAZ,CAAA;YACA,OAAA,IA9GeA,CA8Gf,UAAA,CA9G8B,KAAK,CAAI,CA8GvC;QACA,qBAAA,KAAA,GAAA,KAAA,CA9GmCD;QA+GnC,QAAA,IAAA;YACM,KA9GKD,OAAO;gBA+GlB,IAAA,CAAA,OAAA,EAAA,CAAA;gBACA,OAAA,OAAA,CAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA,CAAA,UAAA,CAAA,KAAA,CAAA;oBACA,iBAAA,CAAA,KAAA,EAAA,OAAA,CAAA,CAAA;YACM,KA9GKD,OA8GX,CAAA;YACM,KA9GKD,OAAa,CA8GxB;YACM,KA9GKD,OAAa,CA8GxB;YACM,KA9GKD,OA8GX,CAAA;YACA,KAAA,SAAA,CA9Ge;YA+GT,KA9GKD,SA8GX,CAAA;YACM,KA9GKD,MA8GX,CAAA;YACA,KAAA,MA9Ge,CA8Gf;YACM,KA9GKD,UA8GX;gBACA,OA9GuB,IA8GvB,CAAA,aAAA,CAAA,KAAA,EAAA,IAAA,CAAA,CAAA;YACM,KA9GKD,GA8GX,CAAA;YACM,KA9GKD,GA8GX;gBACA,OA9GkB,IA8GlB,CAAA,UAAA,EAAA,CAAA;YACM,KA9GKD,KA8GX,CAAA;YACM,KA9GKD,KA8GX,CA9GkB;YA+GlB,KAAA,MA9Ge,CA8Gf;YACM,KA9GKD,KA8GX,CAAA;YACA,KAAA,MA9Ge,CA8Gf;YACM,KA9GKD,QA8GX,CAAA;YACM,KA9GKD,MA8GX;gBACQ,OA9GO,IAAA,CAAK,YA8GpB,CAAA,KAAA,EA9GwC,MA8GxC,CA9G+C,YA8G/C,CAAA,IAAA,CAAA,CA9GuD,CAAY;YA+G7D,KA9GKD,SA8GX;gBACA,OAAA,IAAA,CAAA,mBAAA,CAAA,KAAA,EAAA,GAAA,EAAA,OAAA,EAAA,GAAA,CAAA,CAAA;YACA,KAAA,GAAA,CAAA;YAEM,KA9GKD,GA8GX;gBACQ,OA9GO,IAAA,CAAK,mBAAC,CAAmB,KAAC,EAAM,MA8G/C,CAAA,YAAA,CA9GsE,IA8GtE,CAAA,EAAA,GAAA,EAAA,GAAA,CAAA,CAAA;YACM,KA9GKD,KA8GX,CAAA;YACA,KAAA,GAAA;gBACA,OAAA,IAAA,CAAA,mBAAA,CAAA,KAAA,EAAA,MAAA,CAAA,YAAA,CAAA,IAAA,CAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,CAAA,CAAA;YACA,KAAA,UAAA;gBA9GA,OAAA,IAAA,CAAA,mBAAA,CAAA,KAAA,EAAA,GAAA,EAAA,UAAA,EAAA,GAAA,CAAA,CAAA;YA+GA,KAAA,IAAA;gBACA,OAAA,IAAA,CAAA,mBAAA,CAAA,KAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,CAAA,CAAA;YAEQ,KAAR,KA9GiB;gBA+GjB,OAAA,YAAA,CAAA,IAAA,CAAA,IAAA,CAAA;oBACA,IAAA,CAAA,OAAA,EAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqCA,OAAA,CAAA,SAAA,CAAA,mBApHiB,GAoHjB,UAAA,KAAA,EAAA,GAAA,EAAA,OAAA,EAAA,GAAA,EAAA,SAAA,EAAA,KAAA,EAAA;QACA,IAAA,CAAA,OAAA,EAAA,CAAA;QALE,qBA9GmB,GA8GrB,GAAA,GA9GkC,CA8GlC;QAOA,IAAM,IAAI,CApHC,IAoHX,IAAA,OAAA,EAAA;YACM,IAAN,CAAA,OApHa,EAoHb,CAAA;YACA,GAAA,IAAA,GAAA,CAAA;SALA;QAOA,IAAA,SAAA,IAAA,IAAA,IAAA,IAAA,CAAA,IAAA,IAAA,SAAA,EAAA;;;;QAIA,OAAA,gBAAA,CAAA,KAAA,EAAA,GAAA,CAAA,CAAA;KACA,CAAA;;;;IAGA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;QACI,qBAtHiB,KAAW,GAAG,IAsHnC,CAtHwC,KAsHxC,CAAA;QACA,IAAM,CAAN,OAAA,EAAA,CAAA;QACA,OAAA,gBAAA,CAAA,IAAA,CAAA,IAAA,CAAA;;;;;KAKA,CAAA;;;;;;QAMA,qBAAA,MAAA,IAAA,IAAA,CAAA,KAAA,KAAA,KAAA,CAAA,CAAA;QAzHA,IAAA,CAAA,OAAA,EAAA,CAAA;QA0HA,OAAA,IAAA,EAAA;YACA,IAAA,OAAA,CAAA,IAAA,CAAA,IAAA,CAAA,EAAA;;aACA;iBACA,IAAA,IAAA,CAAA,IAAA,IAzHa,OAyHb,EAAA;gBAzHA,MAAA,GAA4C,KAA5C,CAAA;aA0HA;iBAzHA,IAAA,eAAA,CAAoD,IAApD,CAAA,IAAA,CAAA,EAAA;gBA0HQ,IAAR,CAAA,OAAA,EAzHiB,CAAM;gBA0HvB,IAAA,cAAA,CAAA,IAAA,CAAA,IAAA,CAAA;oBAzHA,IAAA,CAAA,OAAA,EAAA,CAAA;gBA0HQ,IAAR,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA,CAAA;oBACA,OAAA,IAAA,CAAA,KAAA,CAAA,kBAAA,EAAA,CAAA,CAAA,CAAA,CAAA;gBACU,MAAV,GAAA,KAAA,CAAA;aACA;iBACA;gBACA,MAAA;aACA;YACA,IAAA,CAAA,OAAA,EAAA,CAAA;;;;QAIA,OAAA,cAAA,CAAA,KAAA,EAAA,KAAA,CAAA,CAAA;KACA,CAAA;;;;IAKA,OAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;QACI,qBA3HM,KAAA,GAAQ,IAAA,CAAK,KAAC,CAAK;QA6HzB,qBAAJ,KAAA,GAAA,IAAA,CAAA,IAAA,CAAA;QACA,IAAM,CAAN,OA3HW,EA2HX,CAAA;QACA,qBAAA,MAAA,GAAA,EAAA,CA3HyB;QA4HzB,qBAAA,MAAA,GAAA,IAAA,CAAA,KAAA,CAAA;QACA,qBAAA,KAAA,GAAA,IAAA,CAAA,KAAA,CA3H2B;;YA6H3B,IAAQ,IAAI,CA3HC,IAAC,IA2Hd,UAAA,EAAA;gBACQ,MAAR,IAAA,KAAA,CAAA,SAAA,CAAA,MAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAA;;gBAEA,qBAAA,aAAA,GAAA,KAAA,CAAA,CAAA;;gBAEA,IAAA,CAAA,IAAA,GAAA,IAAA,CAAA,IAAyB,CAAzB;gBACA,IAAA,IAAA,CAAA,IAAA,IAAA,EAAA,EAAA;;oBACA,qBAAA,GAAA,GAAA,KAAA,CAAA,SAAA,CAAA,IAAA,CAAA,KA3H6D,GAAG,CA2HhE,EA3HoE,IA2HpE,CAAA,KAAA,GAAA,CAAA,CAAA,CAAA;oBACA,IAAA,cAAA,CAAA,IAAA,CAAA,GAAA,CAAA,EAAA;wBACA,aAAA,GAAA,QAAA,CAAA,GAAA,EA3H0B,EA2H1B,CA3H8B,CAAA;qBA4H9B;yBACA;wBACA,OAAA,IAAA,CAAA,KAAA,CAAA,6BAAA,GAAA,GAAA,GAAA,GAAA,EAAA,CAAA,CAAA,CAAA;qBA3He;oBA4HL,KAAV,qBAAA,CAAA,GA3HwC,CA2HxC,EAAA,CA3HyC,GA2HzC,CAAA,EAAA,CAAA,EAAA,EAAA;wBACc,IAAd,CAAA,OAAA,EAAA,CAAA;qBACA;iBACA;qBACA;oBACA,aAAA,GAAA,QAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;oBA3HA,IAAA,CAAkB,OAAlB,EAA8BD,CAA9B;iBA4HA;gBACA,MAAA,IAAA,MAAA,CAAA,YAAA,CAAA,aAAA,CAAA,CAAA;gBA3HA,MAAA,GAAA,IAAA,CAAA,KAAA,CAAA;aA4HA;iBACA,IAAA,IAAA,CAAA,IAAA,IAAA,IAAA,EAAA;gBACA,OAAA,IAAA,CAAA,KAAA,CAAA,oBAAA,EAAA,CAAA,CAAA,CAAA;aAEA;iBACA;gBAEA,IAAA,CAAA,OAAA,EA3H0B,CA2H1B;aACA;;;;;;;;;;;IAaA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAA,OAAA,EAAA,MAAA,EAAA;;;;IAeA,OAAA,OAAA,CAAA;CAAA,EAAA,CAAA,CAAA;;;;;;;;CAQA;;;;;;;;;;;;CAuBA;;;;;;;CAOA;;;;;;;CAOA;;;;;;;;;AAYA,SAAA,QAAA,CAAA,IAtKoB,EAsKpB;IACA,QAAA,IAAA;QACA,KAAA,EAAA;YACA,OAAA,GAAA,CAAA;QACA,KAAA,EAAA;YACA,OAAA,GAAA,CAAA;QACA,KAAA,EAAA;YACA,OAAA,GAAA,CAAA;QACA,KAAA,EAAA;YACA,OAAA,IAAA,CAAA;QACA,KAAA,EAAA;;QDxiBA;;;;AAEA,IAAA,UAAA,IAAA,YAAA;;;;IDDA,SAAA,UAAA,CAAA,MAAA,EAAA;QACA,IAAA,CAAA,MAAA,GAAM,MAAN,CAAA;;IAGA,OAAA,UAAA,CAAA;CAAA,EAAA,CAAA,CAAA;;;;;;;;;;;;;;;;AAoBA,IACA,oBADA,GAAA,CAAA,CAAA;;;;AAKA,IAAA,eAAA,GAAA,EAAA,CAAmC;AAAnC,IAAA,aAAA,IAAA,YAAA;;;;;;;;;;;;IAYA,aAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAA,IAAA,EAAA,UAAA,EAAA;QACA,qBAAA,SAAA,GAAA,IAAA,CAAA,KAAA,CAAA,gBAAA,CAAA,CAAA;QAJA,qBAAA,IAAA,GAAoC,IAApC,CAAA,WAAA,CAAA,KAAA,CAAA,UAAA,CAAA,CAAA;QAKA,qBAAA,GAAA,CAAA;QACA,IAAA,SAAA,CAAA,SAAA,CAAA,WAAA,CAAA,CAAA,EAAA;YAJA,WAAA,CAAA,kBAAA,EAAA,IAAA,EAAA,UAAA,CAAA,CAAA;SAKA;aACA,IAAA,SAAA,CAAA,UAAA,CAAA,EAAA;YAJA,WAAA,CAAA,sBAAA,EAAA,IAAA,EAAA,UAAA,CAAA,CAAA;SAKA;aACA,IAAA,SAAA,CAAA,SAAA,CAAA,EAAA;YAJA,OAAA,IAAA,uBAAA,CAAA,SAAA,CAAA,YAAA,CAAA,EAAA,IAAA,CAAA,CAAA;SAKA;aACA,IAAA,SAAA,CAAA,aAAA,CAAA,EAAA;YAJA,WAAA,CAAA,iBAAA,EAAA,IAA0B,EAA1B,UAAA,CAAA,CAAA;SAKA;aACA,IAAA,SAAA,CAAA,SAAA,CAAA,EAAA;YAJA,WAAA,CAAA,YAAA,EAAA,IAAA,EAAA,UAAA,CAAA,CAAA;SAKA;aACA,IAAA,SAAA,CAAA,oBAAA,CAAA,EAAA;YAJA,WAAA,CAAA,iBAAA,EAAyC,IAAzC,EAAA,UAAA,CAAA,CAAA;SAKA;aACA,IAAA,SAAA,CAAA,kBAAA,CAAA,EAAA;YAJA,WAAA,CAAA,kBAAA,EAAA,IAAA,EAAA,UAAA,CAAA,CAAA;SAKA;aACA,IAAA,SAAA,CAAA,eAAA,CAAA,EAAA;YACA,OAAA,IAAA,uBAAA,CAAA,SAAA,CAAA,eAAA,CAAA,EAAA,IAAA,CAAA,CAAA;;aAHA;YACQ,MAIR,IAJQ,KAIR,CAAA,wBAJA,GAIA,IAAA,CAAA,CAAA;SACA;;;CAjCA,EAAA,CAAA,CAAA;;IA+BA,EAAA,IAAA,EAAAR,sBAAA,EAAA;CAOA,CAAA;;;;;;CAoBA,CAAA,EAAA,CAAA;AArBA,IAAA,kBAAA,IAAA,YAAA;;;;;;;;CAAA,EAAA,CAAA,CAAA;AAkCA,IAAA,uBAAA,IAAA,UAAA,MAAA,EAAA;IAAA,SAAA,CAAA,uBAAA,EAAA,MAAA,CAAA,CAAA;;;;;IAKA,SAAA,uBAAA,CAAA,SAAA,EAAA,UAAA,EAAA;QAAA,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAA,UAAA,CAAA,IAAA,IAAA,CAAA;;;;;CALA,CAAA,kBAAA,CAAA,CAAA,CAAA;;;;;;;;;;ADpFA,IAAA,QAAA,IAAA,YAAA;;;;;;;;QAKA,IAAA,CAAA,eAAA,GAAA,IAAA,GAAA,EAAA,CAAA;KACA;;;;IAIA,QAAA,CAAA,SAAA,CAAA,8BAAA,GAAA,YAAA;QACA,qBAAA,SAAA,GAAA,EAAA,CAAA;;;;;KAKA,CAAA;;;;;;;;;;;;;;;QAeI,qBAAJ,cAAA,GAVqB,IAUrB,CAAA,eAAA,CAAA,GAAA,CAAA,SAAA,CAAA,CAAA;;YAGA,OAAA,cAAA,CAAA;SACA;;QAEA,qBAAA,QAAA,GAAA,IAAA,CAAA,SAAA,CAAA,OAVgD,CAAW,SAU3D,CAAA,CAAA;;;QAIA,qBAAA,YAAA,CAAA;QACA,IAAA,QAAA,CAAA,UAAA,EAAA;;;;YAOA,YAAA,GAAA,IAVU,CAUV,4BAAA,CAAA,IAAA,UAAA,CAAA,eAAA,CATgD,CAShD,CAAA;SAGA;;QAEA,qBAVyB,qBAUzB,GAAA,IAAA,CAAA,uBAAA,CAAA,SAAA,EAAA,QAAA,CAAA,SAAA,EAAA,YAAA,CAAA,CAAA;;QAEA,qBAAA,gBAAA,GAAAO,kCAAA,CAAA,QAAA,CAAA,QAAA,EAAA,SAAA,EAAA,qBAAA,CAAA,CAAA;QACA,cAAA,GAAA;YACM,IAAN,EAAA,SAAA;YACM,QAAN,EAAgB,QAAhB,CAAA,QAVkB;YAWlB,aAAA,EAAA,QAAA,CAAA,IAAA;YACQ,cAAR,EAVU,QAUV,CAAA,MAAA;YACA,gBAAA,EAAA,gBAAA;YACA,qBAAA,EAAA,qBAAA;;;;;;;;;;;;IAaA,QAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAA,SAAA,EAAA,KAAA,EAAA,QAAA,EAAA;QACA,qBAAA,QAAA,GAAAD,sCAAA,CAAA,WAAA,CAAA,OAAA,CAAA,SAAA,CAAA,CAAA;aACA,GAAU,CAAV,UAAA,QAAA,EAAA,KAAA,EAAA;YACA,qBAfmB,OAenB,GAfiC,QAejC,CAAA,iBAAA,CAAA,CAAA,CAAA,CAAA;YACA,qBAAA,IAf+B,IAAI;gBAgBnC,KAAA,EAAA,QAAA;gBACA,KAAA,EAAA,KAAA,CAAA,MAAA,GAAA,KAAA;gBACA,QAAc,oBAAd;oBACA,KAAA,EAAA,QAAA,CAAA,GAAA,CAfuB,KAevB;oBACA,QAAgB,EAAhB,QAAA,CAAA,GAAA,CAAA,WAf2C;oBAgB3C,OAAA,EAAA,OAAA,CAAA,OAAA;oBACA,IAAc,EAAd,OAAA,CAAA,YAAA,CAAA,GAAA,CAAA,UAAA,GAf4C,EAe5C;wBACA,qBAAA,KAAA,GAAA,CAf2C,CAe3C;wBACA,IAAA,GAAA,CAAA,QAAA,EAAA;4BACA,KAAA,IAAA,CAAA,gBAAA;yBACA;wBACA,IAAgB,GAAhB,CAAA,UAf4B,YAe5BD,oBAAA,EAAA;4BACgB,KAAhB,IAAA,CAf0B,gBAe1B;yBACgB;wBAChB,QAAA;4BACA,KAAA,EAAA,KAAA;4BACA,KAAA,EAAA,GAAA,CAAA,GAAA,CAAA,KAAA;4BACA,QAAA,EAAA,GAAA,CAAA,GAAA,CAAA,WAAA;yBACA,EAAA;qBACA,CAfgB;iBAgBhB,CAAA;aACA,CAAA,CAAA;;;;;KAbA,CAAA;;;;;IAuBA,QAAA,CAAA,SAAA,CAAA,4BAAA,GAAA,UAAA,OAAA,EAAA;;;;;;;;;;;;IAcA,QAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,UAAA,SAAA,EAAA,SAvBU,EAuBV,qBAAA,EAAA;QAAA,IAAA,KAAA,GAAA,IAAA,CAAA;QACA,qBAAA,qBAAA,GAAA,YAAA;YACA,qBAAA,KAAA,GAAA,EAAA,CAAA;YACA,qBAAA,SAAA,GAAA,QAAA,CAAA;;YAEA,qBAAA,eAAA,GAAA,EAAA,CAAA;YACA,IAAA,SAAA,EAAA;;oBAGA,eAAA,CAAA,IAAA,CAAA,QAvB2C,CAuB3C,QAvBoD,CAuBpD,GAAA,IAAA,CAAA;iBACA,CAAA,CAAA;gBACA,SAvBmB,IAuBnB,GAAA,oBAAA;;;YAIM,KAAN,CAAA,oBAAA,CAAA,CAAA,SAAA,CAAA,EAvBsC,KAuBtC,EAAA,KAAA,qBAAA,CAAA;YAEM,qBAAN,iBAAA,GAAA,KAAA,CAAA,KAAA,CAAA,MAAA,GAAA,CAAA,CAAA,CAAA;YACA,SAAA,IAvBiB,KAuBjB,qBAAA;;YAEA,qBAAA,YAAA,GAAA,eAAA,CAAA;YACA,YAAA,CAAA,iBAAA,CAAA,QAAA,CAAA,QAAA,CAAA,GAAA,iBAAA,CAAA;YACA,QAAA;gBACQ,OAAR,EAAA,qBAAA;gBACQ,SAAR,EAAA,SAAA;gBACA,KAAA,EAAA,KAAA;gBACA,iBAAA,EAAA,iBAAA;gBACA,eAAA,EAAA,eAAA;gBACA,YAAA,EAAA,YAAA;;aAtBA,EAAA;SAwBA,CAvBE;QAwBF,OAAA,qBAAA,CAAA;;;CA7JA,EAAA,CAAA,CAAA;;IAwIA,EAAA,IAAA,EAAAL,sBAAA,EAAA;CA0BA,CAAA;;;;ADjLA,QAAA,CAAA,cAAA,GAAA,YAAA,EAAA,OAAA;;;CAAA,CAAA,EAAA,CAAA;;;;;;;;IAGA,SAAA,kBAAA,CAAA,SAAA,EAAA,SAAA,EAAA,SAAA,EAAA;QAAA,IAAA,KAAA,GACU,MADV,CAAA,IAAA,CAAA,IAAA,CACA,IADA,IAAA,CAAA;QASA,KAAA,CAAA,SAAA,GAAA,SAAA,CAAA;;;;QADG,KAKH,CAAA,iBAAA,GALyC,EAKzC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;IAeA,kBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAA,SAAA,EAAA;QAAA,IAAA,KAAA,GAAA,IAAA,CAYA;QAXA,IAAA,CAAO,SAAP,CAAA,iBAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA;QACA,qBAAA,WAAA,GAAAI,8BAAA,CAAA,gBAAA,CAAA;YACA;gBAEA,OAAA,EAAAD,oCAZgB;gBAahB,UAAA,EAAA,YAAA,EAAA,OAAA,KAAA,CAAA,SAAA,CAAA,8BAAA,EAAA,CAAA,EAAA;aACA;;;;;KAKA,CAAA;;;;;;QAMA,IAAA,CAAA,iBAAA,CAAA,IAAA,CAAA,QAAA,CAAA,CAAA;KACA,CAAA;;;;IAIA,kBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;QACI,IAAI,IAAR,CAAA,UAAA,EAAA;YACA,MAAA,IAAA,KAAA,CAAA,0CAAA,CAAA,CAAA;;;QAEA,IAjBQ,CAiBR,iBAAA,CAAA,OAAA,CAAA,UAAA,QAAA,EAAA,EAAA,OAAA,QAAA,EAAA,CAAA,EAAA,CAAA,CAAA;QACA,IAAA,CAAA,UAAA,GAAA,IAAA,CAAA;;;;;IAfA,EAAA,IAAA,EAAAH,sBAAA,EAAA;CAoBA,CAAA;;;;;IDnEA,EAAa,IAAb,EAAAE,oBAAA,GAAA;;IDIA,EAAA,IAAA,EAAA,QAAA,GAAA;CAMA,CAAA,EAAA,CAAA;AAFA,IAAA,QAAA,GAAA,IAAAD,0BAAA,CAAA,eAAA,CAAA,CAAA;AAEA,IAAA,YAAA,IAAA,YAAA;IACA,SAAA,YAAA,GAAA;QAEA,IAAA,CAAA,UAAA,GAAA,CAAA,CAAA;;;;;;;;;;;;IAUA,YAAA,CAAA,SAAA,CAAA,QAAM,GAAN,UAAA,IAFW,EAEX,OAAA,EAAA,OAAA,EAAA;QAAA,IAAA,OAAA,KAAA,KAAA,CAAA,EAAA,EAAA,OAAA,GAAA,IAAA,CAAA,EAAA;QACA,qBAAA,QAAA,GAAA,OAAA,CAAA;QAFA,IAAA,CAAW,UAAX,EAAA,CAAA;QAGA,IAAM,IAAN,YAAA,OAAA,EAAA;YACM,QAAN,GAAA,OAFwB,CAExB,YAAA,CAAA,IAAA,EAAA,QAAA,CAAA,IAAA,QAAA,CAAA;YACA,IAAA,CAAA,aAAA,EAAA,CAAA;SAFA;aAGA,IAAA,IAAA,YAAA,IAAA,EAAA;YACM,QAAN,GAAA,OAFY,CAEZ,SAAA,CAAA,IAAA,EAAA,QAAA,CAAA,IAAA,QAAA,CAAA;YACA,IAAA,CAAA,UAAA,EAAA,CAAA;;;YAIQ,QAAR,GAAA,OAAA,CAAA,YAAA,CAAA,IAF4C,EAE5C,QAAA,CAAA,IAAA,QAAA,CAAA;YACM,IAAN,CAAA,aAAA,EAAA,CAFU;SAGV;;;QAGA,IAAA,CAAA,CAAA,QAAA,IAAA,QAAA,KAAA,OAAA,EAAA;YAFA,qBAAA,YAAA,GAAA,QAAA,CAAA,GAAA,CAAA,qBAAA,CAAA;;;aAKA;SACA;aACA;;;YAGA,IAAA,IAAA,YAAA,OAAA,IAAA,IAAA,CAAA,UAAA,CAAA,MAAA,EAAA;gBACA,KAAA,qBAAA,CAAA,GAAA,CAAA,mBAAA,GAAA,GAAA,IAAA,CAAA,UAAA,CAAA,MAAA,EAAA,CAAA,GAAA,GAAA,EAAA,CAAA,EAAA,EAAA;;oBAGA,IAAA,CAAA,eAAA,EAAA,CAAA;iBACA;aACA;SACA;;QAEA,qBAAA,SAAA,GAAA,IAAA,CAAA,UAAA,CAAA;QACA,IAAA,SAAA,EAAA;YACA,IAAA,CAAA,QAAA,CAAA,SAAA,EAAA,OAAA,EAAA,QAAA,CAAA,CAAA;YACA,OAAA,SAAA,GAAA,SAAA,CAAA,WAAA,EAAA;;aDvDA;SACA;KACA,CAAA;IACA,OAAA,YAAA,CAAA;CAAA,EAAA,CAAA,CAAA;AAEA,IAAA,cAAA,GAAA;;;;;CAKA,CAAA;;;;;AAKA,SAAA,oBAAA,CAAA,MAAA,EAAA;IACA,IAAA,MAAA,KAAA,QAAA,EAAA;QACM,OAAN,MAAA,CAAA;KACA;IACA,IAAA,MAAA,KAAA,UAAA,EAAA;QACA,OAAA,IAAA,CAHS,QAGT,CAAA;KACA;IACA,IAAA,MAAA,KAAA,MAAA,EAAA;QAGA,OAAA,IAAA,CAAA,QAAA,CAAA,IAAA,CAAA;KAHA;IAIA,OAAA,SAAA,CAAA;CACA;;;;;;;;;;;;IAWA,kBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAA,OAAA,EAAA,IAAA,EAAA;;YAHA,OAAA,IAAA,CAAA,eAAA,CAAA;SAKA;QACA,OAAA,IAAA,oBAAA,CAAA,IAAA,CAAA,OAAA,EAAA,OAAA,CAAA,CAAA;;;;;IAFA,EAAA,IAAA,EAAAD,sBAAA,EAAA;CAUA,CAAA;;;;;AAmBA,IAAA,kBAAA,IAAA,YAAA;IAAA,SAAA,kBAAA,GAAA;;;;;;;QAMA,MAAA,IAAA,KAAA,CAAA,iDAAA,CAAA,CAAA;;;;;;;;;;;IAWA,kBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAA,IAAA,EAAA,SAAA,EAAA;;;;;KAKA,CAAA;;;;;IAKA,kBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAA,KAAA,EAAA,EAAA,OAAA,QAAA,CAAA,aAAA,CAAA,KAxCyE,CAwCzE,CAxC0E,EAwC1E,CAAA;;;;;IAKA,kBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UA5CG,KAAA,EA4CH,EAAA,OAAA,QAAA,CAAA,cAAA,CAAA,KAAA,CAAA,CAAA,EAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAgCA,CAAA;;;;;IAKA,kBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UAAA,cAAA,EAAA;QACA,qBAAA,EAAA,GAAA,cAAA,CAAA;QACA,IAAA,OAAA,cAAA,KAAA,QAAA,EAAA;YACA,EAAA,GAhEW,QAgEX,CAAA,aAAA,CAAA,cAAA,CAAA,CAAA;SACA;;;;;KAKA,CAAA;;;;;IAKA,kBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAxEG,IAwEH,EAAA,EAAA,OAAA,IAAA,CAxEuC,UAwEvC,CAAA,EAxEwD,CAwExD;;;;;;;;;;;;;IAYA,kBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAA,EAAA,EAAA,IAAA,EA/EU,KAAa,EAAK,SA+E5B,EAAA;QACA,IAAA,SAAA,EAAA;YACA,EAAA,CAAA,cAAA,CAAA,cAAA,CAAA,SAAA,CAAA,EAAA,SAAA,GAAA,GAAA,GAAA,IAAA,EAAA,KAAA,CAAA,CAAA;;;;;;;;;;;;IAWA,kBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAA,EAAA,EAAA,IAAA,EArFU,SAqFV,EAAA;QACA,IAAA,SAAA,EAAA;YACA,EAAA,CAAA,iBAAA,CAAA,cAAA,CAAA,SAAA,CAAA,EAAA,IAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;IA0BA,kBAAA,CAAA,SAAA,CAAA,QAAM,GAAN,UAAA,EAvGS,EAuGT,KAAA,EAAA,KAAA,EAAA,eAAA,EAAA,YAAA,EAAA;QACA,IAAA,eAAA,IAAA,YAAA,EAAA;YACA,EAAA,CAAA,KAAA,CAAA,WAAA,CAAA,KAAA,EAAA,KAAA,EAAA,YAAA,GAAA,WAAA,GAAA,EAAA,CAAA,CAAA;;;;;;;;;;;;;QAYA,IAAM,eA5Ge,EA4GrB;YACA,EAAA,CAAA,KAAA,CAAA,cAAA,CAAA,KAAA,CAAA,CAAA;SACA;;;;;;;;;;;;;;;;;;;;;;;;;IA0BA,kBAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAA,MAAA,EAAA,KAAA,EAAA,QAAA,EAAA;QACA,IAAA,OAAA,MAAA,KAAA,QAAA,EAAA;YACA,MAAA,GAAA,oBAAA,CAAA,MAAA,CAAA,CAAA;YACA,IAAA,CAAA,MAAA,EAAA;gBACA,MAAA,IAAA,KAAA,CAAA,2BAAA,GAAA,MAAA,GAAA,aAAA,GAAA,KAAA,CAAA,CAAA;aACA;SACA;;;;;CAxLA,EAAA,CAAA,CAAA;AA6LA,IAAA,oBAAA,IAAA,UAAA,MAAA,EAAA;IAAA,SAAA,CAAA,oBAAA,EAAA,MAAA,CAAA,CAAA;;;;;;QAQA,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA,IAAA,CAAA;;;;KAAA;;;;;;;;KAQA,CAAA;;;;;IAKA,oBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAA,IAAA,EAAA;;YD7QA,IAAA,CAAA,WAAA,CAAA,IAAA,CAAA,UAAA,EAAA,IAAA,CAAA,CAAA;SACA;KACA,CAAA;IACA,OAAA,oBAAA,CAAA;CAAA,CCqPA,kBAAA,CDrPA,CAAA,CAAA;AAEAD,IAAAA,kBAAAA,GAAAA;IACE,EAAF,OAAA,EAAAD,uBAAA,EAAA,QAAA,EAAA,kBAAA,EAAA;IACA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,QAAA,EAAA;IAEA,EAAa,OAAb,EAAAD,2BAAA,EAAA,QAAA,EAAA,kBAAA,EAAA;;IDxBA,mBAAA;;;;;;;;;;;;;;;;"}